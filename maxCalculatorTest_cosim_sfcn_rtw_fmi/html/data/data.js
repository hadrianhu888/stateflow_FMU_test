var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"maxCalculatorTest_cosim","ref":false,"files":[{"name":"maxCalculatorTest_cosim_sf.c","type":"source","group":"model","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * maxCalculatorTest_cosim_sf.c\r\n *\r\n * Code generation for model \"maxCalculatorTest_cosim_sf\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:16:36 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include <math.h>\r\n#include \"maxCalculatorTest_cosim_sf.h\"\r\n#include \"maxCalculatorTest_cosim_sf_private.h\"\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n\r\nextern void *maxCalculatorTest_cosim_malloc(SimStruct *S);\r\n\r\n#endif\r\n\r\n#ifndef __RTW_UTFREE__\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\nextern void * utMalloc(size_t);\r\nextern void utFree(void *);\r\n\r\n#endif\r\n#endif                                 /* #ifndef __RTW_UTFREE__ */\r\n\r\n#if defined(MATLAB_MEX_FILE)\r\n#include \"rt_nonfinite.c\"\r\n#endif\r\n\r\nstatic const char_T *RT_MEMORY_ALLOCATION_ERROR =\r\n  \"memory allocation error in generated S-Function\";\r\n\r\n/* Start for root system: '<Root>' */\r\n#define MDL_START\r\n\r\nstatic void mdlStart(SimStruct *S)\r\n{\r\n  /* instance underlying S-Function data */\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n#if defined(MATLAB_MEX_FILE)\r\n\r\n  /* non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n#endif\r\n\r\n  maxCalculatorTest_cosim_malloc(S);\r\n  if (ssGetErrorStatus(S) != (NULL) ) {\r\n    return;\r\n  }\r\n\r\n#endif\r\n\r\n  {\r\n  }\r\n}\r\n\r\n/* Outputs for root system: '<Root>' */\r\nstatic void mdlOutputs(SimStruct *S, int_T tid)\r\n{\r\n  /* Outport: '<Root>/Out1' incorporates:\r\n   *  MinMax: '<Root>/Max'\r\n   */\r\n  ((real_T *)ssGetOutputPortSignal(S, 0))[0] = fmax(fmax(*((const real_T **)\r\n    ssGetInputPortSignalPtrs(S, 0))[0], *((const real_T **)\r\n    ssGetInputPortSignalPtrs(S, 1))[0]), *((const real_T **)\r\n    ssGetInputPortSignalPtrs(S, 2))[0]);\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\n/* Update for root system: '<Root>' */\r\n#define MDL_UPDATE\r\n\r\nstatic void mdlUpdate(SimStruct *S, int_T tid)\r\n{\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\n/* Termination for root system: '<Root>' */\r\nstatic void mdlTerminate(SimStruct *S)\r\n{\r\n\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n\r\n  if (ssGetUserData(S) != (NULL) ) {\r\n    rt_FREE(ssGetLocalBlockIO(S));\r\n  }\r\n\r\n  rt_FREE(ssGetUserData(S));\r\n\r\n#endif\r\n\r\n}\r\n\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n#include \"maxCalculatorTest_cosim_mid.h\"\r\n#endif\r\n\r\n/* Function to initialize sizes. */\r\nstatic void mdlInitializeSizes(SimStruct *S)\r\n{\r\n  ssSetNumSampleTimes(S, 1);           /* Number of sample times */\r\n  ssSetNumContStates(S, 0);            /* Number of continuous states */\r\n  ssSetNumNonsampledZCs(S, 0);         /* Number of nonsampled ZCs */\r\n\r\n  /* Number of output ports */\r\n  if (!ssSetNumOutputPorts(S, 1))\r\n    return;\r\n\r\n  /* outport number: 0 */\r\n  if (!ssSetOutputPortVectorDimension(S, 0, 1))\r\n    return;\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 0, SS_DOUBLE);\r\n  }\r\n\r\n  ssSetOutputPortOptimOpts(S, 0, SS_REUSABLE_AND_LOCAL);\r\n\r\n  /* Number of input ports */\r\n  if (!ssSetNumInputPorts(S, 3))\r\n    return;\r\n\r\n  /* inport number: 0 */\r\n  {\r\n    if (!ssSetInputPortVectorDimension(S, 0, 1))\r\n      return;\r\n    if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n      ssSetInputPortDataType(S, 0, SS_DOUBLE);\r\n    }\r\n\r\n    ssSetInputPortDirectFeedThrough(S, 0, 1);\r\n    ssSetInputPortOverWritable(S, 0, 0);\r\n    ssSetInputPortOptimOpts(S, 0, SS_NOT_REUSABLE_AND_GLOBAL);\r\n  }\r\n\r\n  /* inport number: 1 */\r\n  {\r\n    if (!ssSetInputPortVectorDimension(S, 1, 1))\r\n      return;\r\n    if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n      ssSetInputPortDataType(S, 1, SS_DOUBLE);\r\n    }\r\n\r\n    ssSetInputPortDirectFeedThrough(S, 1, 1);\r\n    ssSetInputPortOverWritable(S, 1, 0);\r\n    ssSetInputPortOptimOpts(S, 1, SS_NOT_REUSABLE_AND_GLOBAL);\r\n  }\r\n\r\n  /* inport number: 2 */\r\n  {\r\n    if (!ssSetInputPortVectorDimension(S, 2, 1))\r\n      return;\r\n    if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n      ssSetInputPortDataType(S, 2, SS_DOUBLE);\r\n    }\r\n\r\n    ssSetInputPortDirectFeedThrough(S, 2, 1);\r\n    ssSetInputPortOverWritable(S, 2, 0);\r\n    ssSetInputPortOptimOpts(S, 2, SS_NOT_REUSABLE_AND_GLOBAL);\r\n  }\r\n\r\n  ssSetRTWGeneratedSFcn(S, 1);         /* Generated S-function */\r\n\r\n  /* Tunable Parameters */\r\n  ssSetNumSFcnParams(S, 0);\r\n\r\n  /* Number of expected parameters */\r\n#if defined(MATLAB_MEX_FILE)\r\n\r\n  if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {\r\n\r\n#if defined(MDL_CHECK_PARAMETERS)\r\n\r\n    mdlCheckParameters(S);\r\n\r\n#endif                                 /* MDL_CHECK_PARAMETERS */\r\n\r\n    if (ssGetErrorStatus(S) != (NULL) ) {\r\n      return;\r\n    }\r\n  } else {\r\n    return;                /* Parameter mismatch will be reported by Simulink */\r\n  }\r\n\r\n#endif                                 /* MATLAB_MEX_FILE */\r\n\r\n  /* Options */\r\n  ssSetOptions(S, (SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE ));\r\n\r\n#if SS_SFCN_FOR_SIM\r\n\r\n  {\r\n    ssSupportsMultipleExecInstances(S, true);\r\n    ssHasStateInsideForEachSS(S, false);\r\n    ssSetModelReferenceSampleTimeInheritanceRule(S,\r\n      USE_DEFAULT_FOR_DISCRETE_INHERITANCE);\r\n  }\r\n\r\n#endif\r\n\r\n}\r\n\r\n/* Function to initialize sample times. */\r\nstatic void mdlInitializeSampleTimes(SimStruct *S)\r\n{\r\n  ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);\r\n  ssSetOffsetTime(S, 0, 0.0);\r\n}\r\n\r\n#if defined(MATLAB_MEX_FILE)\r\n#include \"fixedpoint.c\"\r\n#include \"simulink.c\"\r\n#else\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME                maxCalculatorTest_cosim_sf\r\n#include \"cg_sfun.h\"\r\n#endif                                 /* defined(MATLAB_MEX_FILE) */\r\n"},{"name":"maxCalculatorTest_cosim_sf.h","type":"header","group":"model","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * maxCalculatorTest_cosim_sf.h\r\n *\r\n * Code generation for model \"maxCalculatorTest_cosim_sf\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:16:36 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_maxCalculatorTest_cosim_sf_h_\r\n#define RTW_HEADER_maxCalculatorTest_cosim_sf_h_\r\n#include <math.h>\r\n#include <string.h>\r\n#include <stddef.h>\r\n#ifndef maxCalculatorTest_cosim_sf_COMMON_INCLUDES_\r\n#define maxCalculatorTest_cosim_sf_COMMON_INCLUDES_\r\n#include <stdlib.h>\r\n#define S_FUNCTION_NAME                maxCalculatorTest_cosim_sf\r\n#define S_FUNCTION_LEVEL               2\r\n#ifndef RTW_GENERATED_S_FUNCTION\r\n#define RTW_GENERATED_S_FUNCTION\r\n#endif\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#if !defined(MATLAB_MEX_FILE)\r\n#include \"rt_matrx.h\"\r\n#endif\r\n\r\n#if !defined(RTW_SFUNCTION_DEFINES)\r\n#define RTW_SFUNCTION_DEFINES\r\n\r\ntypedef struct {\r\n  void *blockIO;\r\n  void *defaultParam;\r\n  void *nonContDerivSig;\r\n} LocalS;\r\n\r\n#define ssSetLocalBlockIO(S, io)       ((LocalS *)ssGetUserData(S))->blockIO = ((void *)(io))\r\n#define ssGetLocalBlockIO(S)           ((LocalS *)ssGetUserData(S))->blockIO\r\n#define ssSetLocalDefaultParam(S, paramVector) ((LocalS *)ssGetUserData(S))->defaultParam = (paramVector)\r\n#define ssGetLocalDefaultParam(S)      ((LocalS *)ssGetUserData(S))->defaultParam\r\n#define ssSetLocalNonContDerivSig(S, pSig) ((LocalS *)ssGetUserData(S))->nonContDerivSig = (pSig)\r\n#define ssGetLocalNonContDerivSig(S)   ((LocalS *)ssGetUserData(S))->nonContDerivSig\r\n#endif\r\n#endif                         /* maxCalculatorTest_cosim_sf_COMMON_INCLUDES_ */\r\n\r\n#include \"maxCalculatorTest_cosim_sf_types.h\"\r\n\r\n/* Shared type includes */\r\n#include \"multiword_types.h\"\r\n#include \"rtGetNaN.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"rt_defines.h\"\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real_T *In1;                         /* '<Root>/In1' */\r\n  real_T *In2;                         /* '<Root>/In2' */\r\n  real_T *In3;                         /* '<Root>/In3' */\r\n} ExternalUPtrs_maxCalculatorTest_cosim_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T *Out1;                        /* '<Root>/Out1' */\r\n} ExtY_maxCalculatorTest_cosim_T;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'maxCalculatorTest_cosim_sf'\r\n */\r\n#endif                            /* RTW_HEADER_maxCalculatorTest_cosim_sf_h_ */\r\n"},{"name":"maxCalculatorTest_cosim_sf_private.h","type":"header","group":"model","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * maxCalculatorTest_cosim_sf_private.h\r\n *\r\n * Code generation for model \"maxCalculatorTest_cosim_sf\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:16:36 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_maxCalculatorTest_cosim_sf_private_h_\r\n#define RTW_HEADER_maxCalculatorTest_cosim_sf_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n#if !defined(ss_VALIDATE_MEMORY)\r\n#define ss_VALIDATE_MEMORY(S, ptr)     if(!(ptr)) {\\\r\n ssSetErrorStatus(S, RT_MEMORY_ALLOCATION_ERROR);\\\r\n }\r\n#endif\r\n\r\n#if !defined(rt_FREE)\r\n#if !defined(_WIN32)\r\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\r\n free((ptr));\\\r\n (ptr) = (NULL);\\\r\n }\r\n#else\r\n\r\n/* Visual and other windows compilers declare free without const */\r\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\r\n free((void *)(ptr));\\\r\n (ptr) = (NULL);\\\r\n }\r\n#endif\r\n#endif\r\n#endif                    /* RTW_HEADER_maxCalculatorTest_cosim_sf_private_h_ */\r\n"},{"name":"maxCalculatorTest_cosim_sf_types.h","type":"header","group":"model","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * maxCalculatorTest_cosim_sf_types.h\r\n *\r\n * Code generation for model \"maxCalculatorTest_cosim_sf\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:16:36 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_maxCalculatorTest_cosim_sf_types_h_\r\n#define RTW_HEADER_maxCalculatorTest_cosim_sf_types_h_\r\n\r\n/* Model Code Variants */\r\n#endif                      /* RTW_HEADER_maxCalculatorTest_cosim_sf_types_h_ */\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Code generation for model \"maxCalculatorTest_cosim_sf\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:16:36 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int64_T chunk_T;\r\ntypedef uint64_T uchunk_T;\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long long longlong_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetInf.c\r\n *\r\n * Code generation for model \"maxCalculatorTest_cosim_sf\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:16:36 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, Inf\r\n */\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rtGetInf.h\r\n    *\r\n        * Code generation for model \"maxCalculatorTest_cosim_sf\".\r\n    *\r\n    * Model version              : 1.7\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Thu Jun  2 19:16:36 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rtGetInf_h_\r\n    #define RTW_HEADER_rtGetInf_h_\r\n\r\n\r\n        \r\n\r\n    \r\n#include <stddef.h>\r\n    #include \"rtwtypes.h\"\r\n    #include \"rt_nonfinite.h\"\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        \r\n        extern real_T rtGetInf(void);\r\n            extern real32_T rtGetInfF(void);\r\n            extern real_T rtGetMinusInf(void);\r\n            extern real32_T rtGetMinusInfF(void);\r\n        \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rtGetInf_h_ */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetNaN.c\r\n *\r\n * Code generation for model \"maxCalculatorTest_cosim_sf\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:16:36 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, NaN\r\n */\r\n#include \"rtGetNaN.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\r\n        tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  uint16_T one = 1U;\r\n  enum {\r\n    LittleEndian,\r\n    BigEndian\r\n  } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n  switch (machByteOrder) {\r\n   case LittleEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0xFFC00000U;\r\n      break;\r\n    }\r\n\r\n   case BigEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0x7FFFFFFFU;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return nanF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rtGetNaN.h\r\n    *\r\n        * Code generation for model \"maxCalculatorTest_cosim_sf\".\r\n    *\r\n    * Model version              : 1.7\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Thu Jun  2 19:16:36 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rtGetNaN_h_\r\n    #define RTW_HEADER_rtGetNaN_h_\r\n\r\n\r\n        \r\n\r\n    \r\n#include <stddef.h>\r\n    #include \"rtwtypes.h\"\r\n    #include \"rt_nonfinite.h\"\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        \r\n        extern real_T rtGetNaN(void);\r\n            extern real32_T rtGetNaNF(void);\r\n        \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rtGetNaN_h_ */\r\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rt_defines.h\r\n    *\r\n        * Code generation for model \"maxCalculatorTest_cosim_sf\".\r\n    *\r\n    * Model version              : 1.7\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Thu Jun  2 19:16:36 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rt_defines_h_\r\n    #define RTW_HEADER_rt_defines_h_\r\n\r\n\r\n        \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    /*===========*\r\n    * Constants *\r\n    *===========*/\r\n\r\n    #define RT_PI          3.14159265358979323846\r\n    #define RT_PIF         3.1415927F\r\n    #define RT_LN_10       2.30258509299404568402\r\n    #define RT_LN_10F      2.3025851F\r\n    #define RT_LOG10E      0.43429448190325182765\r\n    #define RT_LOG10EF     0.43429449F\r\n    #define RT_E           2.7182818284590452354\r\n    #define RT_EF          2.7182817F\r\n\r\n    /*\r\n    * UNUSED_PARAMETER(x)\r\n    *   Used to specify that a function parameter (argument) is required but not\r\n    *   accessed by the function body.\r\n    */\r\n    #ifndef UNUSED_PARAMETER\r\n    #if defined(__LCC__)\r\n    #define UNUSED_PARAMETER(x)  /* do nothing */\r\n    #else\r\n    /*\r\n    * This is the semi-ANSI standard way of indicating that an\r\n    * unused function parameter is required.\r\n    */\r\n    #define UNUSED_PARAMETER(x) (void) (x)\r\n    #endif\r\n    #endif\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rt_defines_h_ */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.c\r\n *\r\n * Code generation for model \"maxCalculatorTest_cosim_sf\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:16:36 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finites,\r\n *      (Inf, NaN and -Inf).\r\n */\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rt_nonfinite.h\r\n    *\r\n        * Code generation for model \"maxCalculatorTest_cosim_sf\".\r\n    *\r\n    * Model version              : 1.7\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Thu Jun  2 19:16:36 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rt_nonfinite_h_\r\n    #define RTW_HEADER_rt_nonfinite_h_\r\n\r\n\r\n        \r\n\r\n    \r\n#include <stddef.h>\r\n    #include \"rtwtypes.h\"\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        \r\n    \r\n\r\n\r\n    extern real_T rtInf;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real_T rtMinusInf;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real_T rtNaN;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real32_T rtInfF;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real32_T rtMinusInfF;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real32_T rtNaNF;\r\n\r\n\r\n\r\n        extern void rt_InitInfAndNaN(size_t realSize);\r\n            extern boolean_T rtIsInf(real_T value);\r\n            extern boolean_T rtIsInfF(real32_T value);\r\n            extern boolean_T rtIsNaN(real_T value);\r\n            extern boolean_T rtIsNaNF(real32_T value);\r\n    \r\n    typedef struct  {\r\n    struct {\r\n        uint32_T wordH;\r\n        uint32_T wordL;\r\n    } words;\r\n    } BigEndianIEEEDouble;\r\n\r\n    typedef struct  {\r\n    struct {\r\n        uint32_T wordL;\r\n        uint32_T wordH;\r\n    } words;\r\n    } LittleEndianIEEEDouble;\r\n\r\n    typedef struct  {\r\n    union {\r\n        real32_T wordLreal;\r\n        uint32_T wordLuint;\r\n    } wordL;\r\n    } IEEESingle;\r\n\r\n    \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rt_nonfinite_h_ */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Code generation for model \"maxCalculatorTest_cosim_sf\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:16:36 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n#ifndef INT64_T\r\n#define INT64_T\r\n\r\ntypedef long long int64_T;\r\n\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#endif\r\n\r\n#ifndef UINT64_T\r\n#define UINT64_T\r\n\r\ntypedef unsigned long long uint64_T;\r\n\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n#endif\r\n\r\n/*===========================================================================*\r\n * Additional complex number type definitions                                           *\r\n *===========================================================================*/\r\n#ifndef CINT64_T\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#endif\r\n\r\n#ifndef CUINT64_T\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"maxCalculatorTest_cosim_mid.h","type":"header","group":"interface","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Interface files","code":"/*\r\n * maxCalculatorTest_cosim_mid.h\r\n *\r\n * Code generation for model \"maxCalculatorTest_cosim_sf\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:16:36 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n *\r\n * SOURCES: maxCalculatorTest_cosim_sf.c\r\n */\r\n\r\n#include \"simstruc.h\"\r\n#include \"maxCalculatorTest_cosim_sf.h\"\r\n#if defined(MATLAB_MEX_FILE) || defined(RT_MALLOC)\r\n\r\nstatic int_T RegNumInputPorts(SimStruct *S, int_T nInputPorts)\r\n{\r\n  _ssSetNumInputPorts(S,nInputPorts);\r\n  return true;\r\n}\r\n\r\nstatic int_T RegNumOutputPorts(SimStruct *S, int_T nOutputPorts)\r\n{\r\n  _ssSetNumOutputPorts(S,nOutputPorts);\r\n  return true;\r\n}\r\n\r\nstatic int_T FcnSetErrorStatus(const SimStruct *S, DTypeId arg2)\r\n{\r\n  static char msg[256];\r\n  if (strlen(ssGetModelName(S)) < 128) {\r\n    sprintf(msg,\r\n            \"S-function %s does not have a tlc file. It cannot use macros that access regDataType field in simstruct.\",\r\n            ssGetModelName(S));\r\n  } else {\r\n    sprintf(msg,\r\n            \"A S-function does not have a tlc file. It cannot use macros that access regDataType field in simstruct.\");\r\n  }\r\n\r\n  ssSetErrorStatus(S, msg);\r\n  UNUSED_PARAMETER(arg2);\r\n  return 0;\r\n}\r\n\r\nstatic void * FcnSetErrorStatusWithReturnPtr(const SimStruct *S, DTypeId arg2)\r\n{\r\n  FcnSetErrorStatus(S,0);\r\n  UNUSED_PARAMETER(arg2);\r\n  return 0;\r\n}\r\n\r\nstatic int_T FcnSetErrorStatusWithArgPtr(const SimStruct *S, const void* arg2)\r\n{\r\n  FcnSetErrorStatus(S,0);\r\n  UNUSED_PARAMETER(arg2);\r\n  return 0;\r\n}\r\n\r\n#endif\r\n\r\n/* Instance data for model: maxCalculatorTest_cosim */\r\nvoid *maxCalculatorTest_cosim_malloc(SimStruct *rts)\r\n{\r\n  /* Local SimStruct for the generated S-Function */\r\n  LocalS *lS = (LocalS *) malloc(sizeof(LocalS));\r\n  ss_VALIDATE_MEMORY(rts,lS);\r\n  (void) memset((char *) lS, 0,\r\n                sizeof(LocalS));\r\n  ssSetUserData(rts, lS);\r\n\r\n  /* model checksums */\r\n  ssSetChecksumVal(rts, 0, 2245049582U);\r\n  ssSetChecksumVal(rts, 1, 1426956571U);\r\n  ssSetChecksumVal(rts, 2, 1892112300U);\r\n  ssSetChecksumVal(rts, 3, 2594695460U);\r\n  return (NULL);\r\n}\r\n"},{"name":"maxCalculatorTest_cosim_sid.h","type":"header","group":"interface","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Interface files","code":"/*\r\n * maxCalculatorTest_cosim_sid.h\r\n *\r\n * Code generation for model \"maxCalculatorTest_cosim_sf\".\r\n *\r\n * Model version              : 1.7\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:16:36 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n *\r\n * SOURCES: maxCalculatorTest_cosim_sf.c\r\n */\r\n\r\n/* statically allocated instance data for model: maxCalculatorTest_cosim */\r\n{\r\n  {\r\n    /* Local SimStruct for the generated S-Function */\r\n    static LocalS slS;\r\n    LocalS *lS = &slS;\r\n    ssSetUserData(rts, lS);\r\n\r\n    /* model checksums */\r\n    ssSetChecksumVal(rts, 0, 2245049582U);\r\n    ssSetChecksumVal(rts, 1, 1426956571U);\r\n    ssSetChecksumVal(rts, 2, 1892112300U);\r\n    ssSetChecksumVal(rts, 3, 2594695460U);\r\n  }\r\n}\r\n"},{"name":"CMakeCCompilerId.c","type":"source","group":"other","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi\\CMakeFiles\\3.23.2\\CompilerIdC","tag":"","groupDisplay":"Other files","code":"#ifdef __cplusplus\r\n# error \"A C++ compiler has been selected for C.\"\r\n#endif\r\n\r\n#if defined(__18CXX)\r\n# define ID_VOID_MAIN\r\n#endif\r\n#if defined(__CLASSIC_C__)\r\n/* cv-qualifiers did not exist in K&R C */\r\n# define const\r\n# define volatile\r\n#endif\r\n\r\n#if !defined(__has_include)\r\n/* If the compiler does not have __has_include, pretend the answer is\r\n   always no.  */\r\n#  define __has_include(x) 0\r\n#endif\r\n\r\n\r\n/* Version number components: V=Version, R=Revision, P=Patch\r\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\r\n\r\n#if defined(__INTEL_COMPILER) || defined(__ICC)\r\n# define COMPILER_ID \"Intel\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_ID \"GNU\"\r\n# endif\r\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\r\n     except that a few beta releases use the old format with V=2021.  */\r\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\r\n#  if defined(__INTEL_COMPILER_UPDATE)\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\r\n#  else\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\r\n#  endif\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\r\n   /* The third version component from --version is an update index,\r\n      but no macro is provided for it.  */\r\n#  define COMPILER_VERSION_PATCH DEC(0)\r\n# endif\r\n# if defined(__INTEL_COMPILER_BUILD_DATE)\r\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\r\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\r\n# endif\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n# elif defined(__GNUG__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\r\n# define COMPILER_ID \"IntelLLVM\"\r\n#if defined(_MSC_VER)\r\n# define SIMULATE_ID \"MSVC\"\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_ID \"GNU\"\r\n#endif\r\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\r\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\r\n * VVVV is no smaller than the current year when a version is released.\r\n */\r\n#if __INTEL_LLVM_COMPILER < 1000000L\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\r\n#else\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\r\n#endif\r\n#if defined(_MSC_VER)\r\n  /* _MSC_VER = VVRR */\r\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#elif defined(__GNUG__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n#endif\r\n#if defined(__GNUC_MINOR__)\r\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#endif\r\n#if defined(__GNUC_PATCHLEVEL__)\r\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#endif\r\n\r\n#elif defined(__PATHCC__)\r\n# define COMPILER_ID \"PathScale\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\r\n# if defined(__PATHCC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\r\n# define COMPILER_ID \"Embarcadero\"\r\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\r\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\r\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\r\n\r\n#elif defined(__BORLANDC__)\r\n# define COMPILER_ID \"Borland\"\r\n  /* __BORLANDC__ = 0xVRR */\r\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\r\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\r\n\r\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\r\n# define COMPILER_ID \"Watcom\"\r\n   /* __WATCOMC__ = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\r\n# endif\r\n\r\n#elif defined(__WATCOMC__)\r\n# define COMPILER_ID \"OpenWatcom\"\r\n   /* __WATCOMC__ = VVRP + 1100 */\r\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\r\n# endif\r\n\r\n#elif defined(__SUNPRO_C)\r\n# define COMPILER_ID \"SunPro\"\r\n# if __SUNPRO_C >= 0x5100\r\n   /* __SUNPRO_C = 0xVRRP */\r\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>12)\r\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xFF)\r\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)\r\n# else\r\n   /* __SUNPRO_CC = 0xVRP */\r\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>8)\r\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xF)\r\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)\r\n# endif\r\n\r\n#elif defined(__HP_cc)\r\n# define COMPILER_ID \"HP\"\r\n  /* __HP_cc = VVRRPP */\r\n# define COMPILER_VERSION_MAJOR DEC(__HP_cc/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__HP_cc/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__HP_cc     % 100)\r\n\r\n#elif defined(__DECC)\r\n# define COMPILER_ID \"Compaq\"\r\n  /* __DECC_VER = VVRRTPPPP */\r\n# define COMPILER_VERSION_MAJOR DEC(__DECC_VER/10000000)\r\n# define COMPILER_VERSION_MINOR DEC(__DECC_VER/100000  % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__DECC_VER         % 10000)\r\n\r\n#elif defined(__IBMC__) && defined(__COMPILER_VER__)\r\n# define COMPILER_ID \"zOS\"\r\n  /* __IBMC__ = VRP */\r\n# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)\r\n# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)\r\n\r\n#elif defined(__open_xl__) && defined(__clang__)\r\n# define COMPILER_ID \"IBMClang\"\r\n# define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)\r\n# define COMPILER_VERSION_MINOR DEC(__open_xl_release__)\r\n# define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)\r\n# define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)\r\n\r\n\r\n#elif defined(__ibmxl__) && defined(__clang__)\r\n# define COMPILER_ID \"XLClang\"\r\n# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)\r\n# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)\r\n# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)\r\n# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)\r\n\r\n\r\n#elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ >= 800\r\n# define COMPILER_ID \"XL\"\r\n  /* __IBMC__ = VRP */\r\n# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)\r\n# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)\r\n\r\n#elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ < 800\r\n# define COMPILER_ID \"VisualAge\"\r\n  /* __IBMC__ = VRP */\r\n# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)\r\n# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)\r\n\r\n#elif defined(__NVCOMPILER)\r\n# define COMPILER_ID \"NVHPC\"\r\n# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)\r\n# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)\r\n# if defined(__NVCOMPILER_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__PGI)\r\n# define COMPILER_ID \"PGI\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PGIC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)\r\n# if defined(__PGIC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(_CRAYC)\r\n# define COMPILER_ID \"Cray\"\r\n# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)\r\n# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)\r\n\r\n#elif defined(__TI_COMPILER_VERSION__)\r\n# define COMPILER_ID \"TI\"\r\n  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */\r\n# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)\r\n# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)\r\n# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)\r\n\r\n#elif defined(__CLANG_FUJITSU)\r\n# define COMPILER_ID \"FujitsuClang\"\r\n# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)\r\n# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)\r\n# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)\r\n# define COMPILER_VERSION_INTERNAL_STR __clang_version__\r\n\r\n\r\n#elif defined(__FUJITSU)\r\n# define COMPILER_ID \"Fujitsu\"\r\n# if defined(__FCC_version__)\r\n#   define COMPILER_VERSION __FCC_version__\r\n# elif defined(__FCC_major__)\r\n#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)\r\n#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)\r\n#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)\r\n# endif\r\n# if defined(__fcc_version)\r\n#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)\r\n# elif defined(__FCC_VERSION)\r\n#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)\r\n# endif\r\n\r\n\r\n#elif defined(__ghs__)\r\n# define COMPILER_ID \"GHS\"\r\n/* __GHS_VERSION_NUMBER = VVVVRP */\r\n# ifdef __GHS_VERSION_NUMBER\r\n# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)\r\n# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)\r\n# endif\r\n\r\n#elif defined(__TINYC__)\r\n# define COMPILER_ID \"TinyCC\"\r\n\r\n#elif defined(__BCC__)\r\n# define COMPILER_ID \"Bruce\"\r\n\r\n#elif defined(__SCO_VERSION__)\r\n# define COMPILER_ID \"SCO\"\r\n\r\n#elif defined(__ARMCC_VERSION) && !defined(__clang__)\r\n# define COMPILER_ID \"ARMCC\"\r\n#if __ARMCC_VERSION >= 1000000\r\n  /* __ARMCC_VERSION = VRRPPPP */\r\n  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)\r\n  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)\r\n  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)\r\n#else\r\n  /* __ARMCC_VERSION = VRPPPP */\r\n  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)\r\n  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)\r\n  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)\r\n#endif\r\n\r\n\r\n#elif defined(__clang__) && defined(__apple_build_version__)\r\n# define COMPILER_ID \"AppleClang\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# define COMPILER_VERSION_MAJOR DEC(__clang_major__)\r\n# define COMPILER_VERSION_MINOR DEC(__clang_minor__)\r\n# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)\r\n\r\n#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)\r\n# define COMPILER_ID \"ARMClang\"\r\n  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)\r\n  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)\r\n  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION     % 10000)\r\n# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)\r\n\r\n#elif defined(__clang__)\r\n# define COMPILER_ID \"Clang\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# define COMPILER_VERSION_MAJOR DEC(__clang_major__)\r\n# define COMPILER_VERSION_MINOR DEC(__clang_minor__)\r\n# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n\r\n#elif defined(__LCC__) && (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))\r\n# define COMPILER_ID \"LCC\"\r\n# define COMPILER_VERSION_MAJOR DEC(1)\r\n# if defined(__LCC__)\r\n#  define COMPILER_VERSION_MINOR DEC(__LCC__- 100)\r\n# endif\r\n# if defined(__LCC_MINOR__)\r\n#  define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)\r\n# endif\r\n# if defined(__GNUC__) && defined(__GNUC_MINOR__)\r\n#  define SIMULATE_ID \"GNU\"\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#  if defined(__GNUC_PATCHLEVEL__)\r\n#   define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#  endif\r\n# endif\r\n\r\n#elif defined(__GNUC__)\r\n# define COMPILER_ID \"GNU\"\r\n# define COMPILER_VERSION_MAJOR DEC(__GNUC__)\r\n# if defined(__GNUC_MINOR__)\r\n#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(_MSC_VER)\r\n# define COMPILER_ID \"MSVC\"\r\n  /* _MSC_VER = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# if defined(_MSC_FULL_VER)\r\n#  if _MSC_VER >= 1400\r\n    /* _MSC_FULL_VER = VVRRPPPPP */\r\n#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)\r\n#  else\r\n    /* _MSC_FULL_VER = VVRRPPPP */\r\n#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)\r\n#  endif\r\n# endif\r\n# if defined(_MSC_BUILD)\r\n#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)\r\n# endif\r\n\r\n#elif defined(__VISUALDSPVERSION__) || defined(__ADSPBLACKFIN__) || defined(__ADSPTS__) || defined(__ADSP21000__)\r\n# define COMPILER_ID \"ADSP\"\r\n#if defined(__VISUALDSPVERSION__)\r\n  /* __VISUALDSPVERSION__ = 0xVVRRPP00 */\r\n# define COMPILER_VERSION_MAJOR HEX(__VISUALDSPVERSION__>>24)\r\n# define COMPILER_VERSION_MINOR HEX(__VISUALDSPVERSION__>>16 & 0xFF)\r\n# define COMPILER_VERSION_PATCH HEX(__VISUALDSPVERSION__>>8  & 0xFF)\r\n#endif\r\n\r\n#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)\r\n# define COMPILER_ID \"IAR\"\r\n# if defined(__VER__) && defined(__ICCARM__)\r\n#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)\r\n#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)\r\n#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)\r\n#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)\r\n# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))\r\n#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)\r\n#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))\r\n#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)\r\n#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)\r\n# endif\r\n\r\n#elif defined(__SDCC_VERSION_MAJOR) || defined(SDCC)\r\n# define COMPILER_ID \"SDCC\"\r\n# if defined(__SDCC_VERSION_MAJOR)\r\n#  define COMPILER_VERSION_MAJOR DEC(__SDCC_VERSION_MAJOR)\r\n#  define COMPILER_VERSION_MINOR DEC(__SDCC_VERSION_MINOR)\r\n#  define COMPILER_VERSION_PATCH DEC(__SDCC_VERSION_PATCH)\r\n# else\r\n  /* SDCC = VRP */\r\n#  define COMPILER_VERSION_MAJOR DEC(SDCC/100)\r\n#  define COMPILER_VERSION_MINOR DEC(SDCC/10 % 10)\r\n#  define COMPILER_VERSION_PATCH DEC(SDCC    % 10)\r\n# endif\r\n\r\n\r\n/* These compilers are either not known or too old to define an\r\n  identification macro.  Try to identify the platform and guess that\r\n  it is the native compiler.  */\r\n#elif defined(__hpux) || defined(__hpua)\r\n# define COMPILER_ID \"HP\"\r\n\r\n#else /* unknown compiler */\r\n# define COMPILER_ID \"\"\r\n#endif\r\n\r\n/* Construct the string literal in pieces to prevent the source from\r\n   getting matched.  Store it in a pointer rather than an array\r\n   because some compilers will just produce instructions to fill the\r\n   array rather than assigning a pointer to a static array.  */\r\nchar const* info_compiler = \"INFO\" \":\" \"compiler[\" COMPILER_ID \"]\";\r\n#ifdef SIMULATE_ID\r\nchar const* info_simulate = \"INFO\" \":\" \"simulate[\" SIMULATE_ID \"]\";\r\n#endif\r\n\r\n#ifdef __QNXNTO__\r\nchar const* qnxnto = \"INFO\" \":\" \"qnxnto[]\";\r\n#endif\r\n\r\n#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)\r\nchar const *info_cray = \"INFO\" \":\" \"compiler_wrapper[CrayPrgEnv]\";\r\n#endif\r\n\r\n#define STRINGIFY_HELPER(X) #X\r\n#define STRINGIFY(X) STRINGIFY_HELPER(X)\r\n\r\n/* Identify known platforms by name.  */\r\n#if defined(__linux) || defined(__linux__) || defined(linux)\r\n# define PLATFORM_ID \"Linux\"\r\n\r\n#elif defined(__MSYS__)\r\n# define PLATFORM_ID \"MSYS\"\r\n\r\n#elif defined(__CYGWIN__)\r\n# define PLATFORM_ID \"Cygwin\"\r\n\r\n#elif defined(__MINGW32__)\r\n# define PLATFORM_ID \"MinGW\"\r\n\r\n#elif defined(__APPLE__)\r\n# define PLATFORM_ID \"Darwin\"\r\n\r\n#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)\r\n# define PLATFORM_ID \"Windows\"\r\n\r\n#elif defined(__FreeBSD__) || defined(__FreeBSD)\r\n# define PLATFORM_ID \"FreeBSD\"\r\n\r\n#elif defined(__NetBSD__) || defined(__NetBSD)\r\n# define PLATFORM_ID \"NetBSD\"\r\n\r\n#elif defined(__OpenBSD__) || defined(__OPENBSD)\r\n# define PLATFORM_ID \"OpenBSD\"\r\n\r\n#elif defined(__sun) || defined(sun)\r\n# define PLATFORM_ID \"SunOS\"\r\n\r\n#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)\r\n# define PLATFORM_ID \"AIX\"\r\n\r\n#elif defined(__hpux) || defined(__hpux__)\r\n# define PLATFORM_ID \"HP-UX\"\r\n\r\n#elif defined(__HAIKU__)\r\n# define PLATFORM_ID \"Haiku\"\r\n\r\n#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)\r\n# define PLATFORM_ID \"BeOS\"\r\n\r\n#elif defined(__QNX__) || defined(__QNXNTO__)\r\n# define PLATFORM_ID \"QNX\"\r\n\r\n#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)\r\n# define PLATFORM_ID \"Tru64\"\r\n\r\n#elif defined(__riscos) || defined(__riscos__)\r\n# define PLATFORM_ID \"RISCos\"\r\n\r\n#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)\r\n# define PLATFORM_ID \"SINIX\"\r\n\r\n#elif defined(__UNIX_SV__)\r\n# define PLATFORM_ID \"UNIX_SV\"\r\n\r\n#elif defined(__bsdos__)\r\n# define PLATFORM_ID \"BSDOS\"\r\n\r\n#elif defined(_MPRAS) || defined(MPRAS)\r\n# define PLATFORM_ID \"MP-RAS\"\r\n\r\n#elif defined(__osf) || defined(__osf__)\r\n# define PLATFORM_ID \"OSF1\"\r\n\r\n#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)\r\n# define PLATFORM_ID \"SCO_SV\"\r\n\r\n#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)\r\n# define PLATFORM_ID \"ULTRIX\"\r\n\r\n#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)\r\n# define PLATFORM_ID \"Xenix\"\r\n\r\n#elif defined(__WATCOMC__)\r\n# if defined(__LINUX__)\r\n#  define PLATFORM_ID \"Linux\"\r\n\r\n# elif defined(__DOS__)\r\n#  define PLATFORM_ID \"DOS\"\r\n\r\n# elif defined(__OS2__)\r\n#  define PLATFORM_ID \"OS2\"\r\n\r\n# elif defined(__WINDOWS__)\r\n#  define PLATFORM_ID \"Windows3x\"\r\n\r\n# elif defined(__VXWORKS__)\r\n#  define PLATFORM_ID \"VxWorks\"\r\n\r\n# else /* unknown platform */\r\n#  define PLATFORM_ID\r\n# endif\r\n\r\n#elif defined(__INTEGRITY)\r\n# if defined(INT_178B)\r\n#  define PLATFORM_ID \"Integrity178\"\r\n\r\n# else /* regular Integrity */\r\n#  define PLATFORM_ID \"Integrity\"\r\n# endif\r\n\r\n#else /* unknown platform */\r\n# define PLATFORM_ID\r\n\r\n#endif\r\n\r\n/* For windows compilers MSVC and Intel we can determine\r\n   the architecture of the compiler being used.  This is because\r\n   the compilers do not have flags that can change the architecture,\r\n   but rather depend on which compiler is being used\r\n*/\r\n#if defined(_WIN32) && defined(_MSC_VER)\r\n# if defined(_M_IA64)\r\n#  define ARCHITECTURE_ID \"IA64\"\r\n\r\n# elif defined(_M_ARM64EC)\r\n#  define ARCHITECTURE_ID \"ARM64EC\"\r\n\r\n# elif defined(_M_X64) || defined(_M_AMD64)\r\n#  define ARCHITECTURE_ID \"x64\"\r\n\r\n# elif defined(_M_IX86)\r\n#  define ARCHITECTURE_ID \"X86\"\r\n\r\n# elif defined(_M_ARM64)\r\n#  define ARCHITECTURE_ID \"ARM64\"\r\n\r\n# elif defined(_M_ARM)\r\n#  if _M_ARM == 4\r\n#   define ARCHITECTURE_ID \"ARMV4I\"\r\n#  elif _M_ARM == 5\r\n#   define ARCHITECTURE_ID \"ARMV5I\"\r\n#  else\r\n#   define ARCHITECTURE_ID \"ARMV\" STRINGIFY(_M_ARM)\r\n#  endif\r\n\r\n# elif defined(_M_MIPS)\r\n#  define ARCHITECTURE_ID \"MIPS\"\r\n\r\n# elif defined(_M_SH)\r\n#  define ARCHITECTURE_ID \"SHx\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__WATCOMC__)\r\n# if defined(_M_I86)\r\n#  define ARCHITECTURE_ID \"I86\"\r\n\r\n# elif defined(_M_IX86)\r\n#  define ARCHITECTURE_ID \"X86\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)\r\n# if defined(__ICCARM__)\r\n#  define ARCHITECTURE_ID \"ARM\"\r\n\r\n# elif defined(__ICCRX__)\r\n#  define ARCHITECTURE_ID \"RX\"\r\n\r\n# elif defined(__ICCRH850__)\r\n#  define ARCHITECTURE_ID \"RH850\"\r\n\r\n# elif defined(__ICCRL78__)\r\n#  define ARCHITECTURE_ID \"RL78\"\r\n\r\n# elif defined(__ICCRISCV__)\r\n#  define ARCHITECTURE_ID \"RISCV\"\r\n\r\n# elif defined(__ICCAVR__)\r\n#  define ARCHITECTURE_ID \"AVR\"\r\n\r\n# elif defined(__ICC430__)\r\n#  define ARCHITECTURE_ID \"MSP430\"\r\n\r\n# elif defined(__ICCV850__)\r\n#  define ARCHITECTURE_ID \"V850\"\r\n\r\n# elif defined(__ICC8051__)\r\n#  define ARCHITECTURE_ID \"8051\"\r\n\r\n# elif defined(__ICCSTM8__)\r\n#  define ARCHITECTURE_ID \"STM8\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__ghs__)\r\n# if defined(__PPC64__)\r\n#  define ARCHITECTURE_ID \"PPC64\"\r\n\r\n# elif defined(__ppc__)\r\n#  define ARCHITECTURE_ID \"PPC\"\r\n\r\n# elif defined(__ARM__)\r\n#  define ARCHITECTURE_ID \"ARM\"\r\n\r\n# elif defined(__x86_64__)\r\n#  define ARCHITECTURE_ID \"x64\"\r\n\r\n# elif defined(__i386__)\r\n#  define ARCHITECTURE_ID \"X86\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__TI_COMPILER_VERSION__)\r\n# if defined(__TI_ARM__)\r\n#  define ARCHITECTURE_ID \"ARM\"\r\n\r\n# elif defined(__MSP430__)\r\n#  define ARCHITECTURE_ID \"MSP430\"\r\n\r\n# elif defined(__TMS320C28XX__)\r\n#  define ARCHITECTURE_ID \"TMS320C28x\"\r\n\r\n# elif defined(__TMS320C6X__) || defined(_TMS320C6X)\r\n#  define ARCHITECTURE_ID \"TMS320C6x\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#else\r\n#  define ARCHITECTURE_ID\r\n#endif\r\n\r\n/* Convert integer to decimal digit literals.  */\r\n#define DEC(n)                   \\\r\n  ('0' + (((n) / 10000000)%10)), \\\r\n  ('0' + (((n) / 1000000)%10)),  \\\r\n  ('0' + (((n) / 100000)%10)),   \\\r\n  ('0' + (((n) / 10000)%10)),    \\\r\n  ('0' + (((n) / 1000)%10)),     \\\r\n  ('0' + (((n) / 100)%10)),      \\\r\n  ('0' + (((n) / 10)%10)),       \\\r\n  ('0' +  ((n) % 10))\r\n\r\n/* Convert integer to hex digit literals.  */\r\n#define HEX(n)             \\\r\n  ('0' + ((n)>>28 & 0xF)), \\\r\n  ('0' + ((n)>>24 & 0xF)), \\\r\n  ('0' + ((n)>>20 & 0xF)), \\\r\n  ('0' + ((n)>>16 & 0xF)), \\\r\n  ('0' + ((n)>>12 & 0xF)), \\\r\n  ('0' + ((n)>>8  & 0xF)), \\\r\n  ('0' + ((n)>>4  & 0xF)), \\\r\n  ('0' + ((n)     & 0xF))\r\n\r\n/* Construct a string literal encoding the version number. */\r\n#ifdef COMPILER_VERSION\r\nchar const* info_version = \"INFO\" \":\" \"compiler_version[\" COMPILER_VERSION \"]\";\r\n\r\n/* Construct a string literal encoding the version number components. */\r\n#elif defined(COMPILER_VERSION_MAJOR)\r\nchar const info_version[] = {\r\n  'I', 'N', 'F', 'O', ':',\r\n  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',\r\n  COMPILER_VERSION_MAJOR,\r\n# ifdef COMPILER_VERSION_MINOR\r\n  '.', COMPILER_VERSION_MINOR,\r\n#  ifdef COMPILER_VERSION_PATCH\r\n   '.', COMPILER_VERSION_PATCH,\r\n#   ifdef COMPILER_VERSION_TWEAK\r\n    '.', COMPILER_VERSION_TWEAK,\r\n#   endif\r\n#  endif\r\n# endif\r\n  ']','\\0'};\r\n#endif\r\n\r\n/* Construct a string literal encoding the internal version number. */\r\n#ifdef COMPILER_VERSION_INTERNAL\r\nchar const info_version_internal[] = {\r\n  'I', 'N', 'F', 'O', ':',\r\n  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',\r\n  'i','n','t','e','r','n','a','l','[',\r\n  COMPILER_VERSION_INTERNAL,']','\\0'};\r\n#elif defined(COMPILER_VERSION_INTERNAL_STR)\r\nchar const* info_version_internal = \"INFO\" \":\" \"compiler_version_internal[\" COMPILER_VERSION_INTERNAL_STR \"]\";\r\n#endif\r\n\r\n/* Construct a string literal encoding the version number components. */\r\n#ifdef SIMULATE_VERSION_MAJOR\r\nchar const info_simulate_version[] = {\r\n  'I', 'N', 'F', 'O', ':',\r\n  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',\r\n  SIMULATE_VERSION_MAJOR,\r\n# ifdef SIMULATE_VERSION_MINOR\r\n  '.', SIMULATE_VERSION_MINOR,\r\n#  ifdef SIMULATE_VERSION_PATCH\r\n   '.', SIMULATE_VERSION_PATCH,\r\n#   ifdef SIMULATE_VERSION_TWEAK\r\n    '.', SIMULATE_VERSION_TWEAK,\r\n#   endif\r\n#  endif\r\n# endif\r\n  ']','\\0'};\r\n#endif\r\n\r\n/* Construct the string literal in pieces to prevent the source from\r\n   getting matched.  Store it in a pointer rather than an array\r\n   because some compilers will just produce instructions to fill the\r\n   array rather than assigning a pointer to a static array.  */\r\nchar const* info_platform = \"INFO\" \":\" \"platform[\" PLATFORM_ID \"]\";\r\nchar const* info_arch = \"INFO\" \":\" \"arch[\" ARCHITECTURE_ID \"]\";\r\n\r\n\r\n\r\n#if !defined(__STDC__) && !defined(__clang__)\r\n# if defined(_MSC_VER) || defined(__ibmxl__) || defined(__IBMC__)\r\n#  define C_VERSION \"90\"\r\n# else\r\n#  define C_VERSION\r\n# endif\r\n#elif __STDC_VERSION__ > 201710L\r\n# define C_VERSION \"23\"\r\n#elif __STDC_VERSION__ >= 201710L\r\n# define C_VERSION \"17\"\r\n#elif __STDC_VERSION__ >= 201000L\r\n# define C_VERSION \"11\"\r\n#elif __STDC_VERSION__ >= 199901L\r\n# define C_VERSION \"99\"\r\n#else\r\n# define C_VERSION \"90\"\r\n#endif\r\nconst char* info_language_standard_default =\r\n  \"INFO\" \":\" \"standard_default[\" C_VERSION \"]\";\r\n\r\nconst char* info_language_extensions_default = \"INFO\" \":\" \"extensions_default[\"\r\n#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \\\r\n     defined(__TI_COMPILER_VERSION__)) &&                                     \\\r\n  !defined(__STRICT_ANSI__)\r\n  \"ON\"\r\n#else\r\n  \"OFF\"\r\n#endif\r\n\"]\";\r\n\r\n/*--------------------------------------------------------------------------*/\r\n\r\n#ifdef ID_VOID_MAIN\r\nvoid main() {}\r\n#else\r\n# if defined(__CLASSIC_C__)\r\nint main(argc, argv) int argc; char *argv[];\r\n# else\r\nint main(int argc, char* argv[])\r\n# endif\r\n{\r\n  int require = 0;\r\n  require += info_compiler[argc];\r\n  require += info_platform[argc];\r\n  require += info_arch[argc];\r\n#ifdef COMPILER_VERSION_MAJOR\r\n  require += info_version[argc];\r\n#endif\r\n#ifdef COMPILER_VERSION_INTERNAL\r\n  require += info_version_internal[argc];\r\n#endif\r\n#ifdef SIMULATE_ID\r\n  require += info_simulate[argc];\r\n#endif\r\n#ifdef SIMULATE_VERSION_MAJOR\r\n  require += info_simulate_version[argc];\r\n#endif\r\n#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)\r\n  require += info_cray[argc];\r\n#endif\r\n  require += info_language_standard_default[argc];\r\n  require += info_language_extensions_default[argc];\r\n  (void)argv;\r\n  return require;\r\n}\r\n#endif\r\n"},{"name":"CMakeCXXCompilerId.cpp","type":"source","group":"other","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi\\CMakeFiles\\3.23.2\\CompilerIdCXX","tag":"","groupDisplay":"Other files","code":"/* This source file must have a .cpp extension so that all C++ compilers\r\n   recognize the extension without flags.  Borland does not know .cxx for\r\n   example.  */\r\n#ifndef __cplusplus\r\n# error \"A C compiler has been selected for C++.\"\r\n#endif\r\n\r\n#if !defined(__has_include)\r\n/* If the compiler does not have __has_include, pretend the answer is\r\n   always no.  */\r\n#  define __has_include(x) 0\r\n#endif\r\n\r\n\r\n/* Version number components: V=Version, R=Revision, P=Patch\r\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\r\n\r\n#if defined(__COMO__)\r\n# define COMPILER_ID \"Comeau\"\r\n  /* __COMO_VERSION__ = VRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\r\n\r\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\r\n# define COMPILER_ID \"Intel\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_ID \"GNU\"\r\n# endif\r\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\r\n     except that a few beta releases use the old format with V=2021.  */\r\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\r\n#  if defined(__INTEL_COMPILER_UPDATE)\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\r\n#  else\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\r\n#  endif\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\r\n   /* The third version component from --version is an update index,\r\n      but no macro is provided for it.  */\r\n#  define COMPILER_VERSION_PATCH DEC(0)\r\n# endif\r\n# if defined(__INTEL_COMPILER_BUILD_DATE)\r\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\r\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\r\n# endif\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n# elif defined(__GNUG__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\r\n# define COMPILER_ID \"IntelLLVM\"\r\n#if defined(_MSC_VER)\r\n# define SIMULATE_ID \"MSVC\"\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_ID \"GNU\"\r\n#endif\r\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\r\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\r\n * VVVV is no smaller than the current year when a version is released.\r\n */\r\n#if __INTEL_LLVM_COMPILER < 1000000L\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\r\n#else\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\r\n#endif\r\n#if defined(_MSC_VER)\r\n  /* _MSC_VER = VVRR */\r\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#elif defined(__GNUG__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n#endif\r\n#if defined(__GNUC_MINOR__)\r\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#endif\r\n#if defined(__GNUC_PATCHLEVEL__)\r\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#endif\r\n\r\n#elif defined(__PATHCC__)\r\n# define COMPILER_ID \"PathScale\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\r\n# if defined(__PATHCC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\r\n# define COMPILER_ID \"Embarcadero\"\r\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\r\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\r\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\r\n\r\n#elif defined(__BORLANDC__)\r\n# define COMPILER_ID \"Borland\"\r\n  /* __BORLANDC__ = 0xVRR */\r\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\r\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\r\n\r\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\r\n# define COMPILER_ID \"Watcom\"\r\n   /* __WATCOMC__ = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\r\n# endif\r\n\r\n#elif defined(__WATCOMC__)\r\n# define COMPILER_ID \"OpenWatcom\"\r\n   /* __WATCOMC__ = VVRP + 1100 */\r\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\r\n# endif\r\n\r\n#elif defined(__SUNPRO_CC)\r\n# define COMPILER_ID \"SunPro\"\r\n# if __SUNPRO_CC >= 0x5100\r\n   /* __SUNPRO_CC = 0xVRRP */\r\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>12)\r\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xFF)\r\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\r\n# else\r\n   /* __SUNPRO_CC = 0xVRP */\r\n#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_CC>>8)\r\n#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_CC>>4 & 0xF)\r\n#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_CC    & 0xF)\r\n# endif\r\n\r\n#elif defined(__HP_aCC)\r\n# define COMPILER_ID \"HP\"\r\n  /* __HP_aCC = VVRRPP */\r\n# define COMPILER_VERSION_MAJOR DEC(__HP_aCC/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__HP_aCC/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__HP_aCC     % 100)\r\n\r\n#elif defined(__DECCXX)\r\n# define COMPILER_ID \"Compaq\"\r\n  /* __DECCXX_VER = VVRRTPPPP */\r\n# define COMPILER_VERSION_MAJOR DEC(__DECCXX_VER/10000000)\r\n# define COMPILER_VERSION_MINOR DEC(__DECCXX_VER/100000  % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__DECCXX_VER         % 10000)\r\n\r\n#elif defined(__IBMCPP__) && defined(__COMPILER_VER__)\r\n# define COMPILER_ID \"zOS\"\r\n  /* __IBMCPP__ = VRP */\r\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\r\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\r\n\r\n#elif defined(__open_xl__) && defined(__clang__)\r\n# define COMPILER_ID \"IBMClang\"\r\n# define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)\r\n# define COMPILER_VERSION_MINOR DEC(__open_xl_release__)\r\n# define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)\r\n# define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)\r\n\r\n\r\n#elif defined(__ibmxl__) && defined(__clang__)\r\n# define COMPILER_ID \"XLClang\"\r\n# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)\r\n# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)\r\n# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)\r\n# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)\r\n\r\n\r\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ >= 800\r\n# define COMPILER_ID \"XL\"\r\n  /* __IBMCPP__ = VRP */\r\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\r\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\r\n\r\n#elif defined(__IBMCPP__) && !defined(__COMPILER_VER__) && __IBMCPP__ < 800\r\n# define COMPILER_ID \"VisualAge\"\r\n  /* __IBMCPP__ = VRP */\r\n# define COMPILER_VERSION_MAJOR DEC(__IBMCPP__/100)\r\n# define COMPILER_VERSION_MINOR DEC(__IBMCPP__/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__IBMCPP__    % 10)\r\n\r\n#elif defined(__NVCOMPILER)\r\n# define COMPILER_ID \"NVHPC\"\r\n# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)\r\n# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)\r\n# if defined(__NVCOMPILER_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__PGI)\r\n# define COMPILER_ID \"PGI\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PGIC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)\r\n# if defined(__PGIC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(_CRAYC)\r\n# define COMPILER_ID \"Cray\"\r\n# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)\r\n# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)\r\n\r\n#elif defined(__TI_COMPILER_VERSION__)\r\n# define COMPILER_ID \"TI\"\r\n  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */\r\n# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)\r\n# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)\r\n# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)\r\n\r\n#elif defined(__CLANG_FUJITSU)\r\n# define COMPILER_ID \"FujitsuClang\"\r\n# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)\r\n# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)\r\n# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)\r\n# define COMPILER_VERSION_INTERNAL_STR __clang_version__\r\n\r\n\r\n#elif defined(__FUJITSU)\r\n# define COMPILER_ID \"Fujitsu\"\r\n# if defined(__FCC_version__)\r\n#   define COMPILER_VERSION __FCC_version__\r\n# elif defined(__FCC_major__)\r\n#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)\r\n#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)\r\n#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)\r\n# endif\r\n# if defined(__fcc_version)\r\n#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)\r\n# elif defined(__FCC_VERSION)\r\n#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)\r\n# endif\r\n\r\n\r\n#elif defined(__ghs__)\r\n# define COMPILER_ID \"GHS\"\r\n/* __GHS_VERSION_NUMBER = VVVVRP */\r\n# ifdef __GHS_VERSION_NUMBER\r\n# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)\r\n# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)\r\n# endif\r\n\r\n#elif defined(__SCO_VERSION__)\r\n# define COMPILER_ID \"SCO\"\r\n\r\n#elif defined(__ARMCC_VERSION) && !defined(__clang__)\r\n# define COMPILER_ID \"ARMCC\"\r\n#if __ARMCC_VERSION >= 1000000\r\n  /* __ARMCC_VERSION = VRRPPPP */\r\n  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)\r\n  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)\r\n  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)\r\n#else\r\n  /* __ARMCC_VERSION = VRPPPP */\r\n  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)\r\n  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)\r\n  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)\r\n#endif\r\n\r\n\r\n#elif defined(__clang__) && defined(__apple_build_version__)\r\n# define COMPILER_ID \"AppleClang\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# define COMPILER_VERSION_MAJOR DEC(__clang_major__)\r\n# define COMPILER_VERSION_MINOR DEC(__clang_minor__)\r\n# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)\r\n\r\n#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)\r\n# define COMPILER_ID \"ARMClang\"\r\n  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)\r\n  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)\r\n  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION     % 10000)\r\n# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)\r\n\r\n#elif defined(__clang__)\r\n# define COMPILER_ID \"Clang\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# define COMPILER_VERSION_MAJOR DEC(__clang_major__)\r\n# define COMPILER_VERSION_MINOR DEC(__clang_minor__)\r\n# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n\r\n#elif defined(__LCC__) && (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))\r\n# define COMPILER_ID \"LCC\"\r\n# define COMPILER_VERSION_MAJOR DEC(1)\r\n# if defined(__LCC__)\r\n#  define COMPILER_VERSION_MINOR DEC(__LCC__- 100)\r\n# endif\r\n# if defined(__LCC_MINOR__)\r\n#  define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)\r\n# endif\r\n# if defined(__GNUC__) && defined(__GNUC_MINOR__)\r\n#  define SIMULATE_ID \"GNU\"\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#  if defined(__GNUC_PATCHLEVEL__)\r\n#   define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#  endif\r\n# endif\r\n\r\n#elif defined(__GNUC__) || defined(__GNUG__)\r\n# define COMPILER_ID \"GNU\"\r\n# if defined(__GNUC__)\r\n#  define COMPILER_VERSION_MAJOR DEC(__GNUC__)\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(_MSC_VER)\r\n# define COMPILER_ID \"MSVC\"\r\n  /* _MSC_VER = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# if defined(_MSC_FULL_VER)\r\n#  if _MSC_VER >= 1400\r\n    /* _MSC_FULL_VER = VVRRPPPPP */\r\n#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)\r\n#  else\r\n    /* _MSC_FULL_VER = VVRRPPPP */\r\n#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)\r\n#  endif\r\n# endif\r\n# if defined(_MSC_BUILD)\r\n#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)\r\n# endif\r\n\r\n#elif defined(__VISUALDSPVERSION__) || defined(__ADSPBLACKFIN__) || defined(__ADSPTS__) || defined(__ADSP21000__)\r\n# define COMPILER_ID \"ADSP\"\r\n#if defined(__VISUALDSPVERSION__)\r\n  /* __VISUALDSPVERSION__ = 0xVVRRPP00 */\r\n# define COMPILER_VERSION_MAJOR HEX(__VISUALDSPVERSION__>>24)\r\n# define COMPILER_VERSION_MINOR HEX(__VISUALDSPVERSION__>>16 & 0xFF)\r\n# define COMPILER_VERSION_PATCH HEX(__VISUALDSPVERSION__>>8  & 0xFF)\r\n#endif\r\n\r\n#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)\r\n# define COMPILER_ID \"IAR\"\r\n# if defined(__VER__) && defined(__ICCARM__)\r\n#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)\r\n#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)\r\n#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)\r\n#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)\r\n# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))\r\n#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)\r\n#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))\r\n#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)\r\n#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)\r\n# endif\r\n\r\n\r\n/* These compilers are either not known or too old to define an\r\n  identification macro.  Try to identify the platform and guess that\r\n  it is the native compiler.  */\r\n#elif defined(__hpux) || defined(__hpua)\r\n# define COMPILER_ID \"HP\"\r\n\r\n#else /* unknown compiler */\r\n# define COMPILER_ID \"\"\r\n#endif\r\n\r\n/* Construct the string literal in pieces to prevent the source from\r\n   getting matched.  Store it in a pointer rather than an array\r\n   because some compilers will just produce instructions to fill the\r\n   array rather than assigning a pointer to a static array.  */\r\nchar const* info_compiler = \"INFO\" \":\" \"compiler[\" COMPILER_ID \"]\";\r\n#ifdef SIMULATE_ID\r\nchar const* info_simulate = \"INFO\" \":\" \"simulate[\" SIMULATE_ID \"]\";\r\n#endif\r\n\r\n#ifdef __QNXNTO__\r\nchar const* qnxnto = \"INFO\" \":\" \"qnxnto[]\";\r\n#endif\r\n\r\n#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)\r\nchar const *info_cray = \"INFO\" \":\" \"compiler_wrapper[CrayPrgEnv]\";\r\n#endif\r\n\r\n#define STRINGIFY_HELPER(X) #X\r\n#define STRINGIFY(X) STRINGIFY_HELPER(X)\r\n\r\n/* Identify known platforms by name.  */\r\n#if defined(__linux) || defined(__linux__) || defined(linux)\r\n# define PLATFORM_ID \"Linux\"\r\n\r\n#elif defined(__MSYS__)\r\n# define PLATFORM_ID \"MSYS\"\r\n\r\n#elif defined(__CYGWIN__)\r\n# define PLATFORM_ID \"Cygwin\"\r\n\r\n#elif defined(__MINGW32__)\r\n# define PLATFORM_ID \"MinGW\"\r\n\r\n#elif defined(__APPLE__)\r\n# define PLATFORM_ID \"Darwin\"\r\n\r\n#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)\r\n# define PLATFORM_ID \"Windows\"\r\n\r\n#elif defined(__FreeBSD__) || defined(__FreeBSD)\r\n# define PLATFORM_ID \"FreeBSD\"\r\n\r\n#elif defined(__NetBSD__) || defined(__NetBSD)\r\n# define PLATFORM_ID \"NetBSD\"\r\n\r\n#elif defined(__OpenBSD__) || defined(__OPENBSD)\r\n# define PLATFORM_ID \"OpenBSD\"\r\n\r\n#elif defined(__sun) || defined(sun)\r\n# define PLATFORM_ID \"SunOS\"\r\n\r\n#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)\r\n# define PLATFORM_ID \"AIX\"\r\n\r\n#elif defined(__hpux) || defined(__hpux__)\r\n# define PLATFORM_ID \"HP-UX\"\r\n\r\n#elif defined(__HAIKU__)\r\n# define PLATFORM_ID \"Haiku\"\r\n\r\n#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)\r\n# define PLATFORM_ID \"BeOS\"\r\n\r\n#elif defined(__QNX__) || defined(__QNXNTO__)\r\n# define PLATFORM_ID \"QNX\"\r\n\r\n#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)\r\n# define PLATFORM_ID \"Tru64\"\r\n\r\n#elif defined(__riscos) || defined(__riscos__)\r\n# define PLATFORM_ID \"RISCos\"\r\n\r\n#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)\r\n# define PLATFORM_ID \"SINIX\"\r\n\r\n#elif defined(__UNIX_SV__)\r\n# define PLATFORM_ID \"UNIX_SV\"\r\n\r\n#elif defined(__bsdos__)\r\n# define PLATFORM_ID \"BSDOS\"\r\n\r\n#elif defined(_MPRAS) || defined(MPRAS)\r\n# define PLATFORM_ID \"MP-RAS\"\r\n\r\n#elif defined(__osf) || defined(__osf__)\r\n# define PLATFORM_ID \"OSF1\"\r\n\r\n#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)\r\n# define PLATFORM_ID \"SCO_SV\"\r\n\r\n#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)\r\n# define PLATFORM_ID \"ULTRIX\"\r\n\r\n#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)\r\n# define PLATFORM_ID \"Xenix\"\r\n\r\n#elif defined(__WATCOMC__)\r\n# if defined(__LINUX__)\r\n#  define PLATFORM_ID \"Linux\"\r\n\r\n# elif defined(__DOS__)\r\n#  define PLATFORM_ID \"DOS\"\r\n\r\n# elif defined(__OS2__)\r\n#  define PLATFORM_ID \"OS2\"\r\n\r\n# elif defined(__WINDOWS__)\r\n#  define PLATFORM_ID \"Windows3x\"\r\n\r\n# elif defined(__VXWORKS__)\r\n#  define PLATFORM_ID \"VxWorks\"\r\n\r\n# else /* unknown platform */\r\n#  define PLATFORM_ID\r\n# endif\r\n\r\n#elif defined(__INTEGRITY)\r\n# if defined(INT_178B)\r\n#  define PLATFORM_ID \"Integrity178\"\r\n\r\n# else /* regular Integrity */\r\n#  define PLATFORM_ID \"Integrity\"\r\n# endif\r\n\r\n#else /* unknown platform */\r\n# define PLATFORM_ID\r\n\r\n#endif\r\n\r\n/* For windows compilers MSVC and Intel we can determine\r\n   the architecture of the compiler being used.  This is because\r\n   the compilers do not have flags that can change the architecture,\r\n   but rather depend on which compiler is being used\r\n*/\r\n#if defined(_WIN32) && defined(_MSC_VER)\r\n# if defined(_M_IA64)\r\n#  define ARCHITECTURE_ID \"IA64\"\r\n\r\n# elif defined(_M_ARM64EC)\r\n#  define ARCHITECTURE_ID \"ARM64EC\"\r\n\r\n# elif defined(_M_X64) || defined(_M_AMD64)\r\n#  define ARCHITECTURE_ID \"x64\"\r\n\r\n# elif defined(_M_IX86)\r\n#  define ARCHITECTURE_ID \"X86\"\r\n\r\n# elif defined(_M_ARM64)\r\n#  define ARCHITECTURE_ID \"ARM64\"\r\n\r\n# elif defined(_M_ARM)\r\n#  if _M_ARM == 4\r\n#   define ARCHITECTURE_ID \"ARMV4I\"\r\n#  elif _M_ARM == 5\r\n#   define ARCHITECTURE_ID \"ARMV5I\"\r\n#  else\r\n#   define ARCHITECTURE_ID \"ARMV\" STRINGIFY(_M_ARM)\r\n#  endif\r\n\r\n# elif defined(_M_MIPS)\r\n#  define ARCHITECTURE_ID \"MIPS\"\r\n\r\n# elif defined(_M_SH)\r\n#  define ARCHITECTURE_ID \"SHx\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__WATCOMC__)\r\n# if defined(_M_I86)\r\n#  define ARCHITECTURE_ID \"I86\"\r\n\r\n# elif defined(_M_IX86)\r\n#  define ARCHITECTURE_ID \"X86\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)\r\n# if defined(__ICCARM__)\r\n#  define ARCHITECTURE_ID \"ARM\"\r\n\r\n# elif defined(__ICCRX__)\r\n#  define ARCHITECTURE_ID \"RX\"\r\n\r\n# elif defined(__ICCRH850__)\r\n#  define ARCHITECTURE_ID \"RH850\"\r\n\r\n# elif defined(__ICCRL78__)\r\n#  define ARCHITECTURE_ID \"RL78\"\r\n\r\n# elif defined(__ICCRISCV__)\r\n#  define ARCHITECTURE_ID \"RISCV\"\r\n\r\n# elif defined(__ICCAVR__)\r\n#  define ARCHITECTURE_ID \"AVR\"\r\n\r\n# elif defined(__ICC430__)\r\n#  define ARCHITECTURE_ID \"MSP430\"\r\n\r\n# elif defined(__ICCV850__)\r\n#  define ARCHITECTURE_ID \"V850\"\r\n\r\n# elif defined(__ICC8051__)\r\n#  define ARCHITECTURE_ID \"8051\"\r\n\r\n# elif defined(__ICCSTM8__)\r\n#  define ARCHITECTURE_ID \"STM8\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__ghs__)\r\n# if defined(__PPC64__)\r\n#  define ARCHITECTURE_ID \"PPC64\"\r\n\r\n# elif defined(__ppc__)\r\n#  define ARCHITECTURE_ID \"PPC\"\r\n\r\n# elif defined(__ARM__)\r\n#  define ARCHITECTURE_ID \"ARM\"\r\n\r\n# elif defined(__x86_64__)\r\n#  define ARCHITECTURE_ID \"x64\"\r\n\r\n# elif defined(__i386__)\r\n#  define ARCHITECTURE_ID \"X86\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#elif defined(__TI_COMPILER_VERSION__)\r\n# if defined(__TI_ARM__)\r\n#  define ARCHITECTURE_ID \"ARM\"\r\n\r\n# elif defined(__MSP430__)\r\n#  define ARCHITECTURE_ID \"MSP430\"\r\n\r\n# elif defined(__TMS320C28XX__)\r\n#  define ARCHITECTURE_ID \"TMS320C28x\"\r\n\r\n# elif defined(__TMS320C6X__) || defined(_TMS320C6X)\r\n#  define ARCHITECTURE_ID \"TMS320C6x\"\r\n\r\n# else /* unknown architecture */\r\n#  define ARCHITECTURE_ID \"\"\r\n# endif\r\n\r\n#else\r\n#  define ARCHITECTURE_ID\r\n#endif\r\n\r\n/* Convert integer to decimal digit literals.  */\r\n#define DEC(n)                   \\\r\n  ('0' + (((n) / 10000000)%10)), \\\r\n  ('0' + (((n) / 1000000)%10)),  \\\r\n  ('0' + (((n) / 100000)%10)),   \\\r\n  ('0' + (((n) / 10000)%10)),    \\\r\n  ('0' + (((n) / 1000)%10)),     \\\r\n  ('0' + (((n) / 100)%10)),      \\\r\n  ('0' + (((n) / 10)%10)),       \\\r\n  ('0' +  ((n) % 10))\r\n\r\n/* Convert integer to hex digit literals.  */\r\n#define HEX(n)             \\\r\n  ('0' + ((n)>>28 & 0xF)), \\\r\n  ('0' + ((n)>>24 & 0xF)), \\\r\n  ('0' + ((n)>>20 & 0xF)), \\\r\n  ('0' + ((n)>>16 & 0xF)), \\\r\n  ('0' + ((n)>>12 & 0xF)), \\\r\n  ('0' + ((n)>>8  & 0xF)), \\\r\n  ('0' + ((n)>>4  & 0xF)), \\\r\n  ('0' + ((n)     & 0xF))\r\n\r\n/* Construct a string literal encoding the version number. */\r\n#ifdef COMPILER_VERSION\r\nchar const* info_version = \"INFO\" \":\" \"compiler_version[\" COMPILER_VERSION \"]\";\r\n\r\n/* Construct a string literal encoding the version number components. */\r\n#elif defined(COMPILER_VERSION_MAJOR)\r\nchar const info_version[] = {\r\n  'I', 'N', 'F', 'O', ':',\r\n  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',\r\n  COMPILER_VERSION_MAJOR,\r\n# ifdef COMPILER_VERSION_MINOR\r\n  '.', COMPILER_VERSION_MINOR,\r\n#  ifdef COMPILER_VERSION_PATCH\r\n   '.', COMPILER_VERSION_PATCH,\r\n#   ifdef COMPILER_VERSION_TWEAK\r\n    '.', COMPILER_VERSION_TWEAK,\r\n#   endif\r\n#  endif\r\n# endif\r\n  ']','\\0'};\r\n#endif\r\n\r\n/* Construct a string literal encoding the internal version number. */\r\n#ifdef COMPILER_VERSION_INTERNAL\r\nchar const info_version_internal[] = {\r\n  'I', 'N', 'F', 'O', ':',\r\n  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',\r\n  'i','n','t','e','r','n','a','l','[',\r\n  COMPILER_VERSION_INTERNAL,']','\\0'};\r\n#elif defined(COMPILER_VERSION_INTERNAL_STR)\r\nchar const* info_version_internal = \"INFO\" \":\" \"compiler_version_internal[\" COMPILER_VERSION_INTERNAL_STR \"]\";\r\n#endif\r\n\r\n/* Construct a string literal encoding the version number components. */\r\n#ifdef SIMULATE_VERSION_MAJOR\r\nchar const info_simulate_version[] = {\r\n  'I', 'N', 'F', 'O', ':',\r\n  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',\r\n  SIMULATE_VERSION_MAJOR,\r\n# ifdef SIMULATE_VERSION_MINOR\r\n  '.', SIMULATE_VERSION_MINOR,\r\n#  ifdef SIMULATE_VERSION_PATCH\r\n   '.', SIMULATE_VERSION_PATCH,\r\n#   ifdef SIMULATE_VERSION_TWEAK\r\n    '.', SIMULATE_VERSION_TWEAK,\r\n#   endif\r\n#  endif\r\n# endif\r\n  ']','\\0'};\r\n#endif\r\n\r\n/* Construct the string literal in pieces to prevent the source from\r\n   getting matched.  Store it in a pointer rather than an array\r\n   because some compilers will just produce instructions to fill the\r\n   array rather than assigning a pointer to a static array.  */\r\nchar const* info_platform = \"INFO\" \":\" \"platform[\" PLATFORM_ID \"]\";\r\nchar const* info_arch = \"INFO\" \":\" \"arch[\" ARCHITECTURE_ID \"]\";\r\n\r\n\r\n\r\n#if defined(__INTEL_COMPILER) && defined(_MSVC_LANG) && _MSVC_LANG < 201403L\r\n#  if defined(__INTEL_CXX11_MODE__)\r\n#    if defined(__cpp_aggregate_nsdmi)\r\n#      define CXX_STD 201402L\r\n#    else\r\n#      define CXX_STD 201103L\r\n#    endif\r\n#  else\r\n#    define CXX_STD 199711L\r\n#  endif\r\n#elif defined(_MSC_VER) && defined(_MSVC_LANG)\r\n#  define CXX_STD _MSVC_LANG\r\n#else\r\n#  define CXX_STD __cplusplus\r\n#endif\r\n\r\nconst char* info_language_standard_default = \"INFO\" \":\" \"standard_default[\"\r\n#if CXX_STD > 202002L\r\n  \"23\"\r\n#elif CXX_STD > 201703L\r\n  \"20\"\r\n#elif CXX_STD >= 201703L\r\n  \"17\"\r\n#elif CXX_STD >= 201402L\r\n  \"14\"\r\n#elif CXX_STD >= 201103L\r\n  \"11\"\r\n#else\r\n  \"98\"\r\n#endif\r\n\"]\";\r\n\r\nconst char* info_language_extensions_default = \"INFO\" \":\" \"extensions_default[\"\r\n#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \\\r\n     defined(__TI_COMPILER_VERSION__)) &&                                     \\\r\n  !defined(__STRICT_ANSI__)\r\n  \"ON\"\r\n#else\r\n  \"OFF\"\r\n#endif\r\n\"]\";\r\n\r\n/*--------------------------------------------------------------------------*/\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n  int require = 0;\r\n  require += info_compiler[argc];\r\n  require += info_platform[argc];\r\n#ifdef COMPILER_VERSION_MAJOR\r\n  require += info_version[argc];\r\n#endif\r\n#ifdef COMPILER_VERSION_INTERNAL\r\n  require += info_version_internal[argc];\r\n#endif\r\n#ifdef SIMULATE_ID\r\n  require += info_simulate[argc];\r\n#endif\r\n#ifdef SIMULATE_VERSION_MAJOR\r\n  require += info_simulate_version[argc];\r\n#endif\r\n#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)\r\n  require += info_cray[argc];\r\n#endif\r\n  require += info_language_standard_default[argc];\r\n  require += info_language_extensions_default[argc];\r\n  (void)argv;\r\n  return require;\r\n}\r\n"},{"name":"model_interface.c","type":"source","group":"legacy","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Other files","code":"#include \"maxCalculatorTest_cosim_sf.h\"\r\n#include \"model_interface.h\"\r\n\r\nsize_t getCGTypeSize(DTypeId typeIndex)\r\n{\r\n  switch (typeIndex) {\r\n   case 0:\r\n    return 8;                          /* real_T */\r\n\r\n   case 1:\r\n    return 4;                          /* real32_T */\r\n\r\n   case 2:\r\n    return 1;                          /* int8_T */\r\n\r\n   case 3:\r\n    return 1;                          /* uint8_T */\r\n\r\n   case 4:\r\n    return 2;                          /* int16_T */\r\n\r\n   case 5:\r\n    return 2;                          /* uint16_T */\r\n\r\n   case 6:\r\n    return 4;                          /* int32_T */\r\n\r\n   case 7:\r\n    return 4;                          /* uint32_T */\r\n\r\n   case 8:\r\n    return 1;                          /* boolean_T */\r\n\r\n   case 9:\r\n    return 0;                          /* fcn_call_T */\r\n\r\n   case 10:\r\n    return 4;                          /* int_T */\r\n\r\n   case 11:\r\n    return 8;                          /* pointer_T */\r\n\r\n   case 12:\r\n    return 8;                          /* action_T */\r\n\r\n   case 13:\r\n    return 8;                          /* timer_uint32_pair_T */\r\n\r\n   case 14:\r\n    return 8;                          /* physical_connection */\r\n\r\n   default:\r\n    return 0;                          /* unknown type */\r\n  }\r\n}\r\n\r\nvoid initializeModelVariables(SimStruct* S, ModelVariable modelVariables[])\r\n{\r\n  modelVariables[0].dtypeID = 0;\r\n  modelVariables[0].size = 0;\r\n  modelVariables[0].address = &((*((real_T **)ssGetInputPortSignalPtrs(S, 0))[0]));\r\n  modelVariables[1].dtypeID = 0;\r\n  modelVariables[1].size = 0;\r\n  modelVariables[1].address = &((*((real_T **)ssGetInputPortSignalPtrs(S, 1))[0]));\r\n  modelVariables[2].dtypeID = 0;\r\n  modelVariables[2].size = 0;\r\n  modelVariables[2].address = &((*((real_T **)ssGetInputPortSignalPtrs(S, 2))[0]));\r\n  modelVariables[3].dtypeID = 0;\r\n  modelVariables[3].size = 0;\r\n  modelVariables[3].address = &(((real_T *)ssGetOutputPortSignal(S, 0))[0]);\r\n}\r\n"},{"name":"model_interface.h","type":"header","group":"other","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Other files","code":"#ifndef model_interface_h\r\n#define model_interface_h\r\n#include \"tmwtypes.h\"\r\n#define N_MODEL_VARIABLES              5\r\n\r\ntypedef struct {\r\n  BuiltInDTypeId dtypeID;\r\n  size_t size;\r\n  void* address;\r\n} ModelVariable;\r\n\r\nsize_t getCGTypeSize(DTypeId typeIndex);\r\nvoid initializeModelVariables(SimStruct* S, ModelVariable modelVariables[]);\r\n\r\n#endif                                 /* model_interface_h */\r\n"},{"name":"sfcn_fmi.c","type":"source","group":"legacy","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Other files","code":"/*\r\n * sfcn_fmi.c\r\n *\r\n *  Model-specific code required to build FMI executable\r\n *  from Simulink model \"maxCalculatorTest_cosim\".\r\n *\r\n * Generated on : Thu Jun  2 19:16:35 2022\r\n */\r\n\r\n#include <stddef.h>\r\n#if defined(MATLAB_MEX_FILE)\r\n#include \"mex.h\"\r\n#undef mexCallMATLAB\r\n#define mexCallMATLAB                  sfcn_fmi_load_mex\r\n#else\r\n\r\n/* Code to enable global tunable parameters in stand-alone mode */\r\n#define RTW_GENERATED_SFCN_TUNABLE_PRMS_maxCalculatorTest_cosim_sf\r\n#define RTW_GENERATED_S_FUNCTION\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#if defined (_MSC_VER)\r\n\r\n#pragma warning(disable:4005)\r\n\r\n#endif\r\n\r\n#define mxGetData(x)                   x\r\n#define ssFxpSetU32BitRegionCompliant(S, v)\r\n#include \"rt_nonfinite.c\"\r\n#endif\r\n\r\n/* Include Simulink Coder-generated model code */\r\n#include \"maxCalculatorTest_cosim_sf.c\"\r\n\r\n/* Register model callback routines in SimStruct */\r\nvoid sfcn_fmi_registerMdlCallbacks_(SimStruct*S)\r\n{\r\n  ssSetmdlInitializeSizes(S, mdlInitializeSizes);\r\n  ssSetmdlInitializeSampleTimes(S, mdlInitializeSampleTimes);\r\n\r\n#if defined(MDL_INITIALIZE_CONDITIONS)\r\n\r\n  ssSetmdlInitializeConditions(S, mdlInitializeConditions);\r\n\r\n#else\r\n\r\n  ssSetmdlInitializeConditions(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined(MDL_START)\r\n\r\n  ssSetmdlStart(S, mdlStart);\r\n\r\n#else\r\n\r\n  ssSetmdlStart(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined(RTW_GENERATED_ENABLE)\r\n\r\n  _ssSetRTWGeneratedEnable(S, mdlEnable);\r\n\r\n#else\r\n\r\n  _ssSetRTWGeneratedEnable(S, NULL);\r\n\r\n#endif\r\n\r\n  ssSetmdlOutputs(S,mdlOutputs);\r\n\r\n#if defined(MDL_ZERO_CROSSINGS)\r\n\r\n  ssSetmdlZeroCrossings(S, mdlZeroCrossings);\r\n\r\n#else\r\n\r\n  ssSetmdlZeroCrossings(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined(MDL_DERIVATIVES)\r\n\r\n  ssSetmdlDerivatives(S, mdlDerivatives);\r\n\r\n#else\r\n\r\n  ssSetmdlDerivatives(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined (MDL_UPDATE)\r\n\r\n  ssSetmdlUpdate(S, mdlUpdate);\r\n\r\n#else\r\n\r\n  ssSetmdlUpdate(S, NULL);\r\n\r\n#endif\r\n\r\n  ssSetmdlTerminate(S, mdlTerminate);\r\n}\r\n\r\n/* Register SolverInfo model method pointers */\r\n\r\n/* Empty callback for use as mdlProjection in ODE solver */\r\nstatic void mdlNoOpFunc(SimStruct *S)\r\n{\r\n  return;\r\n}\r\n\r\nvoid sfcn_fmi_registerRTModelCallbacks_(SimStruct*S)\r\n{\r\n\r\n#if defined(MDL_DERIVATIVES)\r\n\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmDervisFcn = (rtMdlDerivativesFcn)\r\n    mdlDerivatives;\r\n\r\n#else\r\n\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmDervisFcn = (rtMdlProjectionFcn)\r\n    mdlNoOpFunc;\r\n\r\n#endif\r\n\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmProjectionFcn =\r\n    (rtMdlProjectionFcn) mdlNoOpFunc;\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmOutputsFcn = (rtMdlOutputsFcn)\r\n    mdlOutputs;\r\n}\r\n\r\n/* Copy parameter values to S-function mxArrays */\r\nvoid sfcn_fmi_copyToSFcnParams_(SimStruct* S)\r\n{\r\n  return;                /* No parameters in model (probably due to inlining) */\r\n}\r\n\r\n/* Handle mxArrays for global tunable parameters */\r\nvoid sfcn_fmi_mxGlobalTunable_(SimStruct* S, int_T create, int_T update)\r\n{\r\n  return;                         /* no global tunable parameters as mxArrays */\r\n}\r\n"},{"name":"sfcn_fmi.h","type":"header","group":"other","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Other files","code":"/*\r\n * Model-specific defintions for \"maxCalculatorTest_cosim\"\r\n *\r\n * Generated on : Thu Jun  2 19:16:35 2022\r\n */\r\n\r\n#pragma once\r\n\r\n#include \"simstruc.h\"\r\n#define MODEL_GUID                     \"{fb532931-2b90-48ce-b0d7-a808eec730d7}\"\r\n\r\n/* Solver settings selected in Simulink */\r\n#define SFCN_FMI_IS_VARIABLE_STEP_SOLVER 0\r\n#define SFCN_FMI_FIXED_STEP_SIZE       0.2\r\n#define SFCN_FMI_IS_MT                 0\r\n#define SFCN_FMI_EXTRAPOLATION_ORDER   -1\r\n#define SFCN_FMI_NEWTON_ITER           -1\r\n\r\n/* Model sizes */\r\n#define SFCN_FMI_ZC_LENGTH             0\r\n\r\n/* Model identifier */\r\n#define SFCN_FMI_MODEL_IDENTIFIER      \"maxCalculatorTest_cosim\"\r\n\r\n/* Loading of MEX binaries, path to MATLAB bin */\r\n#define SFCN_FMI_LOAD_MEX              1\r\n#define SFCN_FMI_MATLAB_BIN            \"D:\\\\Program Files\\\\Matlab\\\\bin\\\\win64\"\r\n#define SFCN_FMI_MEXEXT                \"mexw64\"\r\n#define SFCN_FMI_NBR_MEX               0\r\n\r\nstatic const char* SFCN_FMI_MEX_NAMES[1] = { \"\" };\r\n\r\nextern void sfcn_fmi_mxGlobalTunable_(SimStruct* S, int_T create, int_T update);\r\nextern void* sfcn_fmi_allocateBusObject(int_T isInput, int_T portid, int_T width);\r\nextern void sfcn_fmi_registerMdlCallbacks_(SimStruct* S);\r\nextern void sfcn_fmi_registerRTModelCallbacks_(SimStruct*S);\r\nextern void sfcn_fmi_copyToSFcnParams_(SimStruct* S);\r\nextern void sfcn_fmi_mxGlobalTunable_(SimStruct* S, int_T create, int_T update);\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};