var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"maxCalculatorTest","ref":false,"files":[{"name":"maxCalculatorTest_sf.c","type":"source","group":"model","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * maxCalculatorTest_sf.c\r\n *\r\n * Code generation for model \"maxCalculatorTest_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:04:14 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include <math.h>\r\n#include \"maxCalculatorTest_sf.h\"\r\n#include \"maxCalculatorTest_sf_private.h\"\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n\r\nextern void *maxCalculatorTest_malloc(SimStruct *S);\r\n\r\n#endif\r\n\r\n#ifndef __RTW_UTFREE__\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\nextern void * utMalloc(size_t);\r\nextern void utFree(void *);\r\n\r\n#endif\r\n#endif                                 /* #ifndef __RTW_UTFREE__ */\r\n\r\n#if defined(MATLAB_MEX_FILE)\r\n#include \"rt_nonfinite.c\"\r\n#endif\r\n\r\nstatic const char_T *RT_MEMORY_ALLOCATION_ERROR =\r\n  \"memory allocation error in generated S-Function\";\r\n\r\n/* Start for root system: '<Root>' */\r\n#define MDL_START\r\n\r\nstatic void mdlStart(SimStruct *S)\r\n{\r\n  /* instance underlying S-Function data */\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n#if defined(MATLAB_MEX_FILE)\r\n\r\n  /* non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n#endif\r\n\r\n  maxCalculatorTest_malloc(S);\r\n  if (ssGetErrorStatus(S) != (NULL) ) {\r\n    return;\r\n  }\r\n\r\n#endif\r\n\r\n  {\r\n  }\r\n}\r\n\r\n/* Outputs for root system: '<Root>' */\r\nstatic void mdlOutputs(SimStruct *S, int_T tid)\r\n{\r\n  /* Outport: '<Root>/Out1' incorporates:\r\n   *  MinMax: '<Root>/Max'\r\n   */\r\n  ((real_T *)ssGetOutputPortSignal(S, 0))[0] = fmax(fmax(*((const real_T **)\r\n    ssGetInputPortSignalPtrs(S, 0))[0], *((const real_T **)\r\n    ssGetInputPortSignalPtrs(S, 1))[0]), *((const real_T **)\r\n    ssGetInputPortSignalPtrs(S, 2))[0]);\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\n/* Update for root system: '<Root>' */\r\n#define MDL_UPDATE\r\n\r\nstatic void mdlUpdate(SimStruct *S, int_T tid)\r\n{\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\n/* Termination for root system: '<Root>' */\r\nstatic void mdlTerminate(SimStruct *S)\r\n{\r\n\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n\r\n  if (ssGetUserData(S) != (NULL) ) {\r\n    rt_FREE(ssGetLocalBlockIO(S));\r\n  }\r\n\r\n  rt_FREE(ssGetUserData(S));\r\n\r\n#endif\r\n\r\n}\r\n\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n#include \"maxCalculatorTest_mid.h\"\r\n#endif\r\n\r\n/* Function to initialize sizes. */\r\nstatic void mdlInitializeSizes(SimStruct *S)\r\n{\r\n  ssSetNumSampleTimes(S, 1);           /* Number of sample times */\r\n  ssSetNumContStates(S, 0);            /* Number of continuous states */\r\n  ssSetNumNonsampledZCs(S, 0);         /* Number of nonsampled ZCs */\r\n\r\n  /* Number of output ports */\r\n  if (!ssSetNumOutputPorts(S, 1))\r\n    return;\r\n\r\n  /* outport number: 0 */\r\n  if (!ssSetOutputPortVectorDimension(S, 0, 1))\r\n    return;\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 0, SS_DOUBLE);\r\n  }\r\n\r\n  ssSetOutputPortOptimOpts(S, 0, SS_REUSABLE_AND_LOCAL);\r\n\r\n  /* Number of input ports */\r\n  if (!ssSetNumInputPorts(S, 3))\r\n    return;\r\n\r\n  /* inport number: 0 */\r\n  {\r\n    if (!ssSetInputPortVectorDimension(S, 0, 1))\r\n      return;\r\n    if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n      ssSetInputPortDataType(S, 0, SS_DOUBLE);\r\n    }\r\n\r\n    ssSetInputPortDirectFeedThrough(S, 0, 1);\r\n    ssSetInputPortOverWritable(S, 0, 0);\r\n    ssSetInputPortOptimOpts(S, 0, SS_NOT_REUSABLE_AND_GLOBAL);\r\n  }\r\n\r\n  /* inport number: 1 */\r\n  {\r\n    if (!ssSetInputPortVectorDimension(S, 1, 1))\r\n      return;\r\n    if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n      ssSetInputPortDataType(S, 1, SS_DOUBLE);\r\n    }\r\n\r\n    ssSetInputPortDirectFeedThrough(S, 1, 1);\r\n    ssSetInputPortOverWritable(S, 1, 0);\r\n    ssSetInputPortOptimOpts(S, 1, SS_NOT_REUSABLE_AND_GLOBAL);\r\n  }\r\n\r\n  /* inport number: 2 */\r\n  {\r\n    if (!ssSetInputPortVectorDimension(S, 2, 1))\r\n      return;\r\n    if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n      ssSetInputPortDataType(S, 2, SS_DOUBLE);\r\n    }\r\n\r\n    ssSetInputPortDirectFeedThrough(S, 2, 1);\r\n    ssSetInputPortOverWritable(S, 2, 0);\r\n    ssSetInputPortOptimOpts(S, 2, SS_NOT_REUSABLE_AND_GLOBAL);\r\n  }\r\n\r\n  ssSetRTWGeneratedSFcn(S, 1);         /* Generated S-function */\r\n\r\n  /* Tunable Parameters */\r\n  ssSetNumSFcnParams(S, 0);\r\n\r\n  /* Number of expected parameters */\r\n#if defined(MATLAB_MEX_FILE)\r\n\r\n  if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {\r\n\r\n#if defined(MDL_CHECK_PARAMETERS)\r\n\r\n    mdlCheckParameters(S);\r\n\r\n#endif                                 /* MDL_CHECK_PARAMETERS */\r\n\r\n    if (ssGetErrorStatus(S) != (NULL) ) {\r\n      return;\r\n    }\r\n  } else {\r\n    return;                /* Parameter mismatch will be reported by Simulink */\r\n  }\r\n\r\n#endif                                 /* MATLAB_MEX_FILE */\r\n\r\n  /* Options */\r\n  ssSetOptions(S, (SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE ));\r\n\r\n#if SS_SFCN_FOR_SIM\r\n\r\n  {\r\n    ssSupportsMultipleExecInstances(S, true);\r\n    ssHasStateInsideForEachSS(S, false);\r\n    ssSetModelReferenceSampleTimeInheritanceRule(S,\r\n      USE_DEFAULT_FOR_DISCRETE_INHERITANCE);\r\n  }\r\n\r\n#endif\r\n\r\n}\r\n\r\n/* Function to initialize sample times. */\r\nstatic void mdlInitializeSampleTimes(SimStruct *S)\r\n{\r\n  ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);\r\n  ssSetOffsetTime(S, 0, 0.0);\r\n}\r\n\r\n#if defined(MATLAB_MEX_FILE)\r\n#include \"fixedpoint.c\"\r\n#include \"simulink.c\"\r\n#else\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME                maxCalculatorTest_sf\r\n#include \"cg_sfun.h\"\r\n#endif                                 /* defined(MATLAB_MEX_FILE) */\r\n"},{"name":"maxCalculatorTest_sf.h","type":"header","group":"model","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * maxCalculatorTest_sf.h\r\n *\r\n * Code generation for model \"maxCalculatorTest_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:04:14 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_maxCalculatorTest_sf_h_\r\n#define RTW_HEADER_maxCalculatorTest_sf_h_\r\n#include <math.h>\r\n#include <string.h>\r\n#include <stddef.h>\r\n#ifndef maxCalculatorTest_sf_COMMON_INCLUDES_\r\n#define maxCalculatorTest_sf_COMMON_INCLUDES_\r\n#include <stdlib.h>\r\n#define S_FUNCTION_NAME                maxCalculatorTest_sf\r\n#define S_FUNCTION_LEVEL               2\r\n#ifndef RTW_GENERATED_S_FUNCTION\r\n#define RTW_GENERATED_S_FUNCTION\r\n#endif\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#if !defined(MATLAB_MEX_FILE)\r\n#include \"rt_matrx.h\"\r\n#endif\r\n\r\n#if !defined(RTW_SFUNCTION_DEFINES)\r\n#define RTW_SFUNCTION_DEFINES\r\n\r\ntypedef struct {\r\n  void *blockIO;\r\n  void *defaultParam;\r\n  void *nonContDerivSig;\r\n} LocalS;\r\n\r\n#define ssSetLocalBlockIO(S, io)       ((LocalS *)ssGetUserData(S))->blockIO = ((void *)(io))\r\n#define ssGetLocalBlockIO(S)           ((LocalS *)ssGetUserData(S))->blockIO\r\n#define ssSetLocalDefaultParam(S, paramVector) ((LocalS *)ssGetUserData(S))->defaultParam = (paramVector)\r\n#define ssGetLocalDefaultParam(S)      ((LocalS *)ssGetUserData(S))->defaultParam\r\n#define ssSetLocalNonContDerivSig(S, pSig) ((LocalS *)ssGetUserData(S))->nonContDerivSig = (pSig)\r\n#define ssGetLocalNonContDerivSig(S)   ((LocalS *)ssGetUserData(S))->nonContDerivSig\r\n#endif\r\n#endif                               /* maxCalculatorTest_sf_COMMON_INCLUDES_ */\r\n\r\n#include \"maxCalculatorTest_sf_types.h\"\r\n\r\n/* Shared type includes */\r\n#include \"multiword_types.h\"\r\n#include \"rtGetNaN.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"rt_defines.h\"\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real_T *In1;                         /* '<Root>/In1' */\r\n  real_T *In2;                         /* '<Root>/In2' */\r\n  real_T *In3;                         /* '<Root>/In3' */\r\n} ExternalUPtrs_maxCalculatorTest_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T *Out1;                        /* '<Root>/Out1' */\r\n} ExtY_maxCalculatorTest_T;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'maxCalculatorTest_sf'\r\n */\r\n#endif                                 /* RTW_HEADER_maxCalculatorTest_sf_h_ */\r\n"},{"name":"maxCalculatorTest_sf_private.h","type":"header","group":"model","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * maxCalculatorTest_sf_private.h\r\n *\r\n * Code generation for model \"maxCalculatorTest_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:04:14 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_maxCalculatorTest_sf_private_h_\r\n#define RTW_HEADER_maxCalculatorTest_sf_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n#if !defined(ss_VALIDATE_MEMORY)\r\n#define ss_VALIDATE_MEMORY(S, ptr)     if(!(ptr)) {\\\r\n ssSetErrorStatus(S, RT_MEMORY_ALLOCATION_ERROR);\\\r\n }\r\n#endif\r\n\r\n#if !defined(rt_FREE)\r\n#if !defined(_WIN32)\r\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\r\n free((ptr));\\\r\n (ptr) = (NULL);\\\r\n }\r\n#else\r\n\r\n/* Visual and other windows compilers declare free without const */\r\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\r\n free((void *)(ptr));\\\r\n (ptr) = (NULL);\\\r\n }\r\n#endif\r\n#endif\r\n#endif                          /* RTW_HEADER_maxCalculatorTest_sf_private_h_ */\r\n"},{"name":"maxCalculatorTest_sf_types.h","type":"header","group":"model","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * maxCalculatorTest_sf_types.h\r\n *\r\n * Code generation for model \"maxCalculatorTest_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:04:14 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_maxCalculatorTest_sf_types_h_\r\n#define RTW_HEADER_maxCalculatorTest_sf_types_h_\r\n\r\n/* Model Code Variants */\r\n#endif                            /* RTW_HEADER_maxCalculatorTest_sf_types_h_ */\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Code generation for model \"maxCalculatorTest_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:04:14 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int64_T chunk_T;\r\ntypedef uint64_T uchunk_T;\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long long longlong_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetInf.c\r\n *\r\n * Code generation for model \"maxCalculatorTest_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:04:14 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, Inf\r\n */\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rtGetInf.h\r\n    *\r\n        * Code generation for model \"maxCalculatorTest_sf\".\r\n    *\r\n    * Model version              : 1.5\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Thu Jun  2 19:04:14 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rtGetInf_h_\r\n    #define RTW_HEADER_rtGetInf_h_\r\n\r\n\r\n        \r\n\r\n    \r\n#include <stddef.h>\r\n    #include \"rtwtypes.h\"\r\n    #include \"rt_nonfinite.h\"\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        \r\n        extern real_T rtGetInf(void);\r\n            extern real32_T rtGetInfF(void);\r\n            extern real_T rtGetMinusInf(void);\r\n            extern real32_T rtGetMinusInfF(void);\r\n        \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rtGetInf_h_ */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetNaN.c\r\n *\r\n * Code generation for model \"maxCalculatorTest_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:04:14 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, NaN\r\n */\r\n#include \"rtGetNaN.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\r\n        tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  uint16_T one = 1U;\r\n  enum {\r\n    LittleEndian,\r\n    BigEndian\r\n  } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n  switch (machByteOrder) {\r\n   case LittleEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0xFFC00000U;\r\n      break;\r\n    }\r\n\r\n   case BigEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0x7FFFFFFFU;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return nanF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rtGetNaN.h\r\n    *\r\n        * Code generation for model \"maxCalculatorTest_sf\".\r\n    *\r\n    * Model version              : 1.5\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Thu Jun  2 19:04:14 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rtGetNaN_h_\r\n    #define RTW_HEADER_rtGetNaN_h_\r\n\r\n\r\n        \r\n\r\n    \r\n#include <stddef.h>\r\n    #include \"rtwtypes.h\"\r\n    #include \"rt_nonfinite.h\"\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        \r\n        extern real_T rtGetNaN(void);\r\n            extern real32_T rtGetNaNF(void);\r\n        \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rtGetNaN_h_ */\r\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rt_defines.h\r\n    *\r\n        * Code generation for model \"maxCalculatorTest_sf\".\r\n    *\r\n    * Model version              : 1.5\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Thu Jun  2 19:04:14 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rt_defines_h_\r\n    #define RTW_HEADER_rt_defines_h_\r\n\r\n\r\n        \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    /*===========*\r\n    * Constants *\r\n    *===========*/\r\n\r\n    #define RT_PI          3.14159265358979323846\r\n    #define RT_PIF         3.1415927F\r\n    #define RT_LN_10       2.30258509299404568402\r\n    #define RT_LN_10F      2.3025851F\r\n    #define RT_LOG10E      0.43429448190325182765\r\n    #define RT_LOG10EF     0.43429449F\r\n    #define RT_E           2.7182818284590452354\r\n    #define RT_EF          2.7182817F\r\n\r\n    /*\r\n    * UNUSED_PARAMETER(x)\r\n    *   Used to specify that a function parameter (argument) is required but not\r\n    *   accessed by the function body.\r\n    */\r\n    #ifndef UNUSED_PARAMETER\r\n    #if defined(__LCC__)\r\n    #define UNUSED_PARAMETER(x)  /* do nothing */\r\n    #else\r\n    /*\r\n    * This is the semi-ANSI standard way of indicating that an\r\n    * unused function parameter is required.\r\n    */\r\n    #define UNUSED_PARAMETER(x) (void) (x)\r\n    #endif\r\n    #endif\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rt_defines_h_ */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.c\r\n *\r\n * Code generation for model \"maxCalculatorTest_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:04:14 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finites,\r\n *      (Inf, NaN and -Inf).\r\n */\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rt_nonfinite.h\r\n    *\r\n        * Code generation for model \"maxCalculatorTest_sf\".\r\n    *\r\n    * Model version              : 1.5\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Thu Jun  2 19:04:14 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rt_nonfinite_h_\r\n    #define RTW_HEADER_rt_nonfinite_h_\r\n\r\n\r\n        \r\n\r\n    \r\n#include <stddef.h>\r\n    #include \"rtwtypes.h\"\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        \r\n    \r\n\r\n\r\n    extern real_T rtInf;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real_T rtMinusInf;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real_T rtNaN;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real32_T rtInfF;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real32_T rtMinusInfF;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real32_T rtNaNF;\r\n\r\n\r\n\r\n        extern void rt_InitInfAndNaN(size_t realSize);\r\n            extern boolean_T rtIsInf(real_T value);\r\n            extern boolean_T rtIsInfF(real32_T value);\r\n            extern boolean_T rtIsNaN(real_T value);\r\n            extern boolean_T rtIsNaNF(real32_T value);\r\n    \r\n    typedef struct  {\r\n    struct {\r\n        uint32_T wordH;\r\n        uint32_T wordL;\r\n    } words;\r\n    } BigEndianIEEEDouble;\r\n\r\n    typedef struct  {\r\n    struct {\r\n        uint32_T wordL;\r\n        uint32_T wordH;\r\n    } words;\r\n    } LittleEndianIEEEDouble;\r\n\r\n    typedef struct  {\r\n    union {\r\n        real32_T wordLreal;\r\n        uint32_T wordLuint;\r\n    } wordL;\r\n    } IEEESingle;\r\n\r\n    \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rt_nonfinite_h_ */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Code generation for model \"maxCalculatorTest_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:04:14 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n#ifndef INT64_T\r\n#define INT64_T\r\n\r\ntypedef long long int64_T;\r\n\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#endif\r\n\r\n#ifndef UINT64_T\r\n#define UINT64_T\r\n\r\ntypedef unsigned long long uint64_T;\r\n\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n#endif\r\n\r\n/*===========================================================================*\r\n * Additional complex number type definitions                                           *\r\n *===========================================================================*/\r\n#ifndef CINT64_T\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#endif\r\n\r\n#ifndef CUINT64_T\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"maxCalculatorTest_mid.h","type":"header","group":"interface","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Interface files","code":"/*\r\n * maxCalculatorTest_mid.h\r\n *\r\n * Code generation for model \"maxCalculatorTest_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:04:14 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n *\r\n * SOURCES: maxCalculatorTest_sf.c\r\n */\r\n\r\n#include \"simstruc.h\"\r\n#include \"maxCalculatorTest_sf.h\"\r\n#if defined(MATLAB_MEX_FILE) || defined(RT_MALLOC)\r\n\r\nstatic int_T RegNumInputPorts(SimStruct *S, int_T nInputPorts)\r\n{\r\n  _ssSetNumInputPorts(S,nInputPorts);\r\n  return true;\r\n}\r\n\r\nstatic int_T RegNumOutputPorts(SimStruct *S, int_T nOutputPorts)\r\n{\r\n  _ssSetNumOutputPorts(S,nOutputPorts);\r\n  return true;\r\n}\r\n\r\nstatic int_T FcnSetErrorStatus(const SimStruct *S, DTypeId arg2)\r\n{\r\n  static char msg[256];\r\n  if (strlen(ssGetModelName(S)) < 128) {\r\n    sprintf(msg,\r\n            \"S-function %s does not have a tlc file. It cannot use macros that access regDataType field in simstruct.\",\r\n            ssGetModelName(S));\r\n  } else {\r\n    sprintf(msg,\r\n            \"A S-function does not have a tlc file. It cannot use macros that access regDataType field in simstruct.\");\r\n  }\r\n\r\n  ssSetErrorStatus(S, msg);\r\n  UNUSED_PARAMETER(arg2);\r\n  return 0;\r\n}\r\n\r\nstatic void * FcnSetErrorStatusWithReturnPtr(const SimStruct *S, DTypeId arg2)\r\n{\r\n  FcnSetErrorStatus(S,0);\r\n  UNUSED_PARAMETER(arg2);\r\n  return 0;\r\n}\r\n\r\nstatic int_T FcnSetErrorStatusWithArgPtr(const SimStruct *S, const void* arg2)\r\n{\r\n  FcnSetErrorStatus(S,0);\r\n  UNUSED_PARAMETER(arg2);\r\n  return 0;\r\n}\r\n\r\n#endif\r\n\r\n/* Instance data for model: maxCalculatorTest */\r\nvoid *maxCalculatorTest_malloc(SimStruct *rts)\r\n{\r\n  /* Local SimStruct for the generated S-Function */\r\n  LocalS *lS = (LocalS *) malloc(sizeof(LocalS));\r\n  ss_VALIDATE_MEMORY(rts,lS);\r\n  (void) memset((char *) lS, 0,\r\n                sizeof(LocalS));\r\n  ssSetUserData(rts, lS);\r\n\r\n  /* model checksums */\r\n  ssSetChecksumVal(rts, 0, 1044411538U);\r\n  ssSetChecksumVal(rts, 1, 3456578291U);\r\n  ssSetChecksumVal(rts, 2, 1449229105U);\r\n  ssSetChecksumVal(rts, 3, 4260785677U);\r\n  return (NULL);\r\n}\r\n"},{"name":"maxCalculatorTest_sid.h","type":"header","group":"interface","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Interface files","code":"/*\r\n * maxCalculatorTest_sid.h\r\n *\r\n * Code generation for model \"maxCalculatorTest_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Thu Jun  2 19:04:14 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n *\r\n * SOURCES: maxCalculatorTest_sf.c\r\n */\r\n\r\n/* statically allocated instance data for model: maxCalculatorTest */\r\n{\r\n  {\r\n    /* Local SimStruct for the generated S-Function */\r\n    static LocalS slS;\r\n    LocalS *lS = &slS;\r\n    ssSetUserData(rts, lS);\r\n\r\n    /* model checksums */\r\n    ssSetChecksumVal(rts, 0, 1044411538U);\r\n    ssSetChecksumVal(rts, 1, 3456578291U);\r\n    ssSetChecksumVal(rts, 2, 1449229105U);\r\n    ssSetChecksumVal(rts, 3, 4260785677U);\r\n  }\r\n}\r\n"},{"name":"model_interface.c","type":"source","group":"legacy","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Other files","code":"#include \"maxCalculatorTest_sf.h\"\r\n#include \"model_interface.h\"\r\n\r\nsize_t getCGTypeSize(DTypeId typeIndex)\r\n{\r\n  switch (typeIndex) {\r\n   case 0:\r\n    return 8;                          /* real_T */\r\n\r\n   case 1:\r\n    return 4;                          /* real32_T */\r\n\r\n   case 2:\r\n    return 1;                          /* int8_T */\r\n\r\n   case 3:\r\n    return 1;                          /* uint8_T */\r\n\r\n   case 4:\r\n    return 2;                          /* int16_T */\r\n\r\n   case 5:\r\n    return 2;                          /* uint16_T */\r\n\r\n   case 6:\r\n    return 4;                          /* int32_T */\r\n\r\n   case 7:\r\n    return 4;                          /* uint32_T */\r\n\r\n   case 8:\r\n    return 1;                          /* boolean_T */\r\n\r\n   case 9:\r\n    return 0;                          /* fcn_call_T */\r\n\r\n   case 10:\r\n    return 4;                          /* int_T */\r\n\r\n   case 11:\r\n    return 8;                          /* pointer_T */\r\n\r\n   case 12:\r\n    return 8;                          /* action_T */\r\n\r\n   case 13:\r\n    return 8;                          /* timer_uint32_pair_T */\r\n\r\n   case 14:\r\n    return 8;                          /* physical_connection */\r\n\r\n   default:\r\n    return 0;                          /* unknown type */\r\n  }\r\n}\r\n\r\nvoid initializeModelVariables(SimStruct* S, ModelVariable modelVariables[])\r\n{\r\n  modelVariables[0].dtypeID = 0;\r\n  modelVariables[0].size = 0;\r\n  modelVariables[0].address = &((*((real_T **)ssGetInputPortSignalPtrs(S, 0))[0]));\r\n  modelVariables[1].dtypeID = 0;\r\n  modelVariables[1].size = 0;\r\n  modelVariables[1].address = &((*((real_T **)ssGetInputPortSignalPtrs(S, 1))[0]));\r\n  modelVariables[2].dtypeID = 0;\r\n  modelVariables[2].size = 0;\r\n  modelVariables[2].address = &((*((real_T **)ssGetInputPortSignalPtrs(S, 2))[0]));\r\n  modelVariables[3].dtypeID = 0;\r\n  modelVariables[3].size = 0;\r\n  modelVariables[3].address = &(((real_T *)ssGetOutputPortSignal(S, 0))[0]);\r\n}\r\n"},{"name":"model_interface.h","type":"header","group":"other","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Other files","code":"#ifndef model_interface_h\r\n#define model_interface_h\r\n#include \"tmwtypes.h\"\r\n#define N_MODEL_VARIABLES              5\r\n\r\ntypedef struct {\r\n  BuiltInDTypeId dtypeID;\r\n  size_t size;\r\n  void* address;\r\n} ModelVariable;\r\n\r\nsize_t getCGTypeSize(DTypeId typeIndex);\r\nvoid initializeModelVariables(SimStruct* S, ModelVariable modelVariables[]);\r\n\r\n#endif                                 /* model_interface_h */\r\n"},{"name":"sfcn_fmi.c","type":"source","group":"legacy","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Other files","code":"/*\r\n * sfcn_fmi.c\r\n *\r\n *  Model-specific code required to build FMI executable\r\n *  from Simulink model \"maxCalculatorTest\".\r\n *\r\n * Generated on : Thu Jun  2 19:04:14 2022\r\n */\r\n\r\n#include <stddef.h>\r\n#if defined(MATLAB_MEX_FILE)\r\n#include \"mex.h\"\r\n#undef mexCallMATLAB\r\n#define mexCallMATLAB                  sfcn_fmi_load_mex\r\n#else\r\n\r\n/* Code to enable global tunable parameters in stand-alone mode */\r\n#define RTW_GENERATED_SFCN_TUNABLE_PRMS_maxCalculatorTest_sf\r\n#define RTW_GENERATED_S_FUNCTION\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#if defined (_MSC_VER)\r\n\r\n#pragma warning(disable:4005)\r\n\r\n#endif\r\n\r\n#define mxGetData(x)                   x\r\n#define ssFxpSetU32BitRegionCompliant(S, v)\r\n#include \"rt_nonfinite.c\"\r\n#endif\r\n\r\n/* Include Simulink Coder-generated model code */\r\n#include \"maxCalculatorTest_sf.c\"\r\n\r\n/* Register model callback routines in SimStruct */\r\nvoid sfcn_fmi_registerMdlCallbacks_(SimStruct*S)\r\n{\r\n  ssSetmdlInitializeSizes(S, mdlInitializeSizes);\r\n  ssSetmdlInitializeSampleTimes(S, mdlInitializeSampleTimes);\r\n\r\n#if defined(MDL_INITIALIZE_CONDITIONS)\r\n\r\n  ssSetmdlInitializeConditions(S, mdlInitializeConditions);\r\n\r\n#else\r\n\r\n  ssSetmdlInitializeConditions(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined(MDL_START)\r\n\r\n  ssSetmdlStart(S, mdlStart);\r\n\r\n#else\r\n\r\n  ssSetmdlStart(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined(RTW_GENERATED_ENABLE)\r\n\r\n  _ssSetRTWGeneratedEnable(S, mdlEnable);\r\n\r\n#else\r\n\r\n  _ssSetRTWGeneratedEnable(S, NULL);\r\n\r\n#endif\r\n\r\n  ssSetmdlOutputs(S,mdlOutputs);\r\n\r\n#if defined(MDL_ZERO_CROSSINGS)\r\n\r\n  ssSetmdlZeroCrossings(S, mdlZeroCrossings);\r\n\r\n#else\r\n\r\n  ssSetmdlZeroCrossings(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined(MDL_DERIVATIVES)\r\n\r\n  ssSetmdlDerivatives(S, mdlDerivatives);\r\n\r\n#else\r\n\r\n  ssSetmdlDerivatives(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined (MDL_UPDATE)\r\n\r\n  ssSetmdlUpdate(S, mdlUpdate);\r\n\r\n#else\r\n\r\n  ssSetmdlUpdate(S, NULL);\r\n\r\n#endif\r\n\r\n  ssSetmdlTerminate(S, mdlTerminate);\r\n}\r\n\r\n/* Register SolverInfo model method pointers */\r\n\r\n/* Empty callback for use as mdlProjection in ODE solver */\r\nstatic void mdlNoOpFunc(SimStruct *S)\r\n{\r\n  return;\r\n}\r\n\r\nvoid sfcn_fmi_registerRTModelCallbacks_(SimStruct*S)\r\n{\r\n\r\n#if defined(MDL_DERIVATIVES)\r\n\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmDervisFcn = (rtMdlDerivativesFcn)\r\n    mdlDerivatives;\r\n\r\n#else\r\n\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmDervisFcn = (rtMdlProjectionFcn)\r\n    mdlNoOpFunc;\r\n\r\n#endif\r\n\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmProjectionFcn =\r\n    (rtMdlProjectionFcn) mdlNoOpFunc;\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmOutputsFcn = (rtMdlOutputsFcn)\r\n    mdlOutputs;\r\n}\r\n\r\n/* Copy parameter values to S-function mxArrays */\r\nvoid sfcn_fmi_copyToSFcnParams_(SimStruct* S)\r\n{\r\n  return;                /* No parameters in model (probably due to inlining) */\r\n}\r\n\r\n/* Handle mxArrays for global tunable parameters */\r\nvoid sfcn_fmi_mxGlobalTunable_(SimStruct* S, int_T create, int_T update)\r\n{\r\n  return;                         /* no global tunable parameters as mxArrays */\r\n}\r\n"},{"name":"sfcn_fmi.h","type":"header","group":"other","path":"F:\\GitHubRepos\\stateflow_FMU_test\\maxCalculatorTest_sfcn_rtw_fmi","tag":"","groupDisplay":"Other files","code":"/*\r\n * Model-specific defintions for \"maxCalculatorTest\"\r\n *\r\n * Generated on : Thu Jun  2 19:04:14 2022\r\n */\r\n\r\n#pragma once\r\n\r\n#include \"simstruc.h\"\r\n#define MODEL_GUID                     \"{8af8fad9-ae66-4d8b-b7aa-3cc90f94ab08}\"\r\n\r\n/* Solver settings selected in Simulink */\r\n#define SFCN_FMI_IS_VARIABLE_STEP_SOLVER 0\r\n#define SFCN_FMI_FIXED_STEP_SIZE       0.2\r\n#define SFCN_FMI_IS_MT                 0\r\n#define SFCN_FMI_EXTRAPOLATION_ORDER   -1\r\n#define SFCN_FMI_NEWTON_ITER           -1\r\n\r\n/* Model sizes */\r\n#define SFCN_FMI_ZC_LENGTH             0\r\n\r\n/* Model identifier */\r\n#define SFCN_FMI_MODEL_IDENTIFIER      \"maxCalculatorTest\"\r\n\r\n/* Loading of MEX binaries, path to MATLAB bin */\r\n#define SFCN_FMI_LOAD_MEX              1\r\n#define SFCN_FMI_MATLAB_BIN            \"D:\\\\Program Files\\\\Matlab\\\\bin\\\\win64\"\r\n#define SFCN_FMI_MEXEXT                \"mexw64\"\r\n#define SFCN_FMI_NBR_MEX               0\r\n\r\nstatic const char* SFCN_FMI_MEX_NAMES[1] = { \"\" };\r\n\r\nextern void sfcn_fmi_mxGlobalTunable_(SimStruct* S, int_T create, int_T update);\r\nextern void* sfcn_fmi_allocateBusObject(int_T isInput, int_T portid, int_T width);\r\nextern void sfcn_fmi_registerMdlCallbacks_(SimStruct* S);\r\nextern void sfcn_fmi_registerRTModelCallbacks_(SimStruct*S);\r\nextern void sfcn_fmi_copyToSFcnParams_(SimStruct* S);\r\nextern void sfcn_fmi_mxGlobalTunable_(SimStruct* S, int_T create, int_T update);\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};