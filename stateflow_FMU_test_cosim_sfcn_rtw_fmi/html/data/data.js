var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"stateflow_FMU_test_cosim","ref":false,"files":[{"name":"stateflow_FMU_test_cosim_sf.c","type":"source","group":"model","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * stateflow_FMU_test_cosim_sf.c\r\n *\r\n * Code generation for model \"stateflow_FMU_test_cosim_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Wed Jun  1 19:09:22 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include <math.h>\r\n#include \"stateflow_FMU_test_cosim_sf.h\"\r\n#include \"stateflow_FMU_test_cosim_sf_private.h\"\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n\r\n/* Named constants for Chart: '<Root>/State Flow FMU Test' */\r\n#define stateflow_FMU_test_cos_IN_delay ((uint8_T)1U)\r\n#define stateflow_FMU_test_cos_IN_queue ((uint8_T)4U)\r\n#define stateflow_FMU_test_cos_IN_start ((uint8_T)5U)\r\n#define stateflow_FMU_test_cosi_IN_wait ((uint8_T)6U)\r\n#define stateflow_FMU_test_cosim_IN_off ((uint8_T)2U)\r\n#define stateflow_FMU_test_cosim_IN_on ((uint8_T)3U)\r\n#define stateflow_FM_IN_NO_ACTIVE_CHILD ((uint8_T)0U)\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n\r\nextern void *stateflow_FMU_test_cosim_malloc(SimStruct *S);\r\n\r\n#endif\r\n\r\n#ifndef __RTW_UTFREE__\r\n#if defined (MATLAB_MEX_FILE)\r\n\r\nextern void * utMalloc(size_t);\r\nextern void utFree(void *);\r\n\r\n#endif\r\n#endif                                 /* #ifndef __RTW_UTFREE__ */\r\n\r\n#if defined(MATLAB_MEX_FILE)\r\n#include \"rt_nonfinite.c\"\r\n#endif\r\n\r\nstatic const char_T *RT_MEMORY_ALLOCATION_ERROR =\r\n  \"memory allocation error in generated S-Function\";\r\n\r\n/* System initialize for root system: '<Root>' */\r\n#define MDL_INITIALIZE_CONDITIONS\r\n\r\nstatic void mdlInitializeConditions(SimStruct *S)\r\n{\r\n  if (ssIsFirstInitCond(S)) {\r\n    B_stateflow_FMU_test_cosim_T *_rtB;\r\n    _rtB = ((B_stateflow_FMU_test_cosim_T *) ssGetLocalBlockIO(S));\r\n\r\n    /* SystemInitialize for Chart: '<Root>/State Flow FMU Test' */\r\n    ((uint8_T *)ssGetDWork(S, 0))[0] = 0U;\r\n    ((uint8_T *)ssGetDWork(S, 1))[0] = stateflow_FM_IN_NO_ACTIVE_CHILD;\r\n    _rtB->waitState = 0.0;\r\n    _rtB->onState = 0.0;\r\n    _rtB->offState = 0.0;\r\n    _rtB->delayState = 0.0;\r\n    _rtB->queueState = 0.0;\r\n    _rtB->startState = 0.0;\r\n  } else {\r\n    B_stateflow_FMU_test_cosim_T *_rtB;\r\n    _rtB = ((B_stateflow_FMU_test_cosim_T *) ssGetLocalBlockIO(S));\r\n\r\n    /* SystemReset for Chart: '<Root>/State Flow FMU Test' */\r\n    ((uint8_T *)ssGetDWork(S, 0))[0] = 0U;\r\n    ((uint8_T *)ssGetDWork(S, 1))[0] = stateflow_FM_IN_NO_ACTIVE_CHILD;\r\n    _rtB->waitState = 0.0;\r\n    _rtB->onState = 0.0;\r\n    _rtB->offState = 0.0;\r\n    _rtB->delayState = 0.0;\r\n    _rtB->queueState = 0.0;\r\n    _rtB->startState = 0.0;\r\n  }\r\n}\r\n\r\n/* Start for root system: '<Root>' */\r\n#define MDL_START\r\n\r\nstatic void mdlStart(SimStruct *S)\r\n{\r\n  /* instance underlying S-Function data */\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n#if defined(MATLAB_MEX_FILE)\r\n\r\n  /* non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n#endif\r\n\r\n  stateflow_FMU_test_cosim_malloc(S);\r\n  if (ssGetErrorStatus(S) != (NULL) ) {\r\n    return;\r\n  }\r\n\r\n#endif\r\n\r\n  {\r\n  }\r\n}\r\n\r\n/* Outputs for root system: '<Root>' */\r\nstatic void mdlOutputs(SimStruct *S, int_T tid)\r\n{\r\n  B_stateflow_FMU_test_cosim_T *_rtB;\r\n  _rtB = ((B_stateflow_FMU_test_cosim_T *) ssGetLocalBlockIO(S));\r\n\r\n  /* Chart: '<Root>/State Flow FMU Test' */\r\n  /* Gateway: State Flow FMU Test */\r\n  /* During: State Flow FMU Test */\r\n  if (((uint8_T *)ssGetDWork(S, 0))[0] == 0U) {\r\n    /* Entry: State Flow FMU Test */\r\n    ((uint8_T *)ssGetDWork(S, 0))[0] = 1U;\r\n\r\n    /* Entry Internal: State Flow FMU Test */\r\n    /* Transition: '<S1>:2' */\r\n    ((uint8_T *)ssGetDWork(S, 1))[0] = stateflow_FMU_test_cos_IN_start;\r\n\r\n    /* Entry 'start': '<S1>:1' */\r\n    _rtB->startState = 1.0;\r\n    _rtB->delayState = 1.0;\r\n  } else {\r\n    switch (((uint8_T *)ssGetDWork(S, 1))[0]) {\r\n     case stateflow_FMU_test_cos_IN_delay:\r\n      /* During 'delay': '<S1>:6' */\r\n      if (*((const real_T **)ssGetInputPortSignalPtrs(S, 0))[0] == 0.0) {\r\n        /* Transition: '<S1>:16' */\r\n        ((uint8_T *)ssGetDWork(S, 1))[0] = stateflow_FMU_test_cosi_IN_wait;\r\n\r\n        /* Entry 'wait': '<S1>:5' */\r\n        _rtB->waitState = 1.0;\r\n      } else if (*((const real_T **)ssGetInputPortSignalPtrs(S, 3))[0] == 1.0) {\r\n        /* Transition: '<S1>:18' */\r\n        ((uint8_T *)ssGetDWork(S, 1))[0] = stateflow_FMU_test_cos_IN_queue;\r\n\r\n        /* Entry 'queue': '<S1>:7' */\r\n      }\r\n      break;\r\n\r\n     case stateflow_FMU_test_cosim_IN_off:\r\n      /* During 'off': '<S1>:4' */\r\n      if ((*((const real_T **)ssGetInputPortSignalPtrs(S, 5))[0] == 0.0) && (*((\r\n             const real_T **)ssGetInputPortSignalPtrs(S, 1))[0] == 0.0)) {\r\n        /* Transition: '<S1>:12' */\r\n        ((uint8_T *)ssGetDWork(S, 1))[0] = stateflow_FMU_test_cos_IN_start;\r\n\r\n        /* Entry 'start': '<S1>:1' */\r\n        _rtB->startState = 1.0;\r\n        _rtB->delayState = 1.0;\r\n      } else if (*((const real_T **)ssGetInputPortSignalPtrs(S, 2))[0] == 1.0) {\r\n        /* Transition: '<S1>:22' */\r\n        ((uint8_T *)ssGetDWork(S, 1))[0] = stateflow_FMU_test_cosim_IN_on;\r\n\r\n        /* Entry 'on': '<S1>:3' */\r\n        _rtB->onState = 1.0;\r\n      }\r\n      break;\r\n\r\n     case stateflow_FMU_test_cosim_IN_on:\r\n      /* During 'on': '<S1>:3' */\r\n      if ((*((const real_T **)ssGetInputPortSignalPtrs(S, 4))[0] == 1.0) && (*((\r\n             const real_T **)ssGetInputPortSignalPtrs(S, 2))[0] == 1.0)) {\r\n        /* Transition: '<S1>:10' */\r\n        ((uint8_T *)ssGetDWork(S, 1))[0] = stateflow_FMU_test_cosi_IN_wait;\r\n\r\n        /* Entry 'wait': '<S1>:5' */\r\n        _rtB->waitState = 1.0;\r\n      } else if (*((const real_T **)ssGetInputPortSignalPtrs(S, 1))[0] == 1.0) {\r\n        /* Transition: '<S1>:21' */\r\n        ((uint8_T *)ssGetDWork(S, 1))[0] = stateflow_FMU_test_cosim_IN_off;\r\n\r\n        /* Entry 'off': '<S1>:4' */\r\n      } else {\r\n        _rtB->onState = 1.0;\r\n      }\r\n      break;\r\n\r\n     case stateflow_FMU_test_cos_IN_queue:\r\n      /* During 'queue': '<S1>:7' */\r\n      if (*((const real_T **)ssGetInputPortSignalPtrs(S, 3))[0] == 1.0) {\r\n        /* Transition: '<S1>:19' */\r\n        ((uint8_T *)ssGetDWork(S, 1))[0] = stateflow_FMU_test_cos_IN_delay;\r\n\r\n        /* Entry 'delay': '<S1>:6' */\r\n      } else if (*((const real_T **)ssGetInputPortSignalPtrs(S, 1))[0] == 1.0) {\r\n        /* Transition: '<S1>:23' */\r\n        ((uint8_T *)ssGetDWork(S, 1))[0] = stateflow_FMU_test_cosim_IN_off;\r\n\r\n        /* Entry 'off': '<S1>:4' */\r\n      }\r\n      break;\r\n\r\n     case stateflow_FMU_test_cos_IN_start:\r\n      /* During 'start': '<S1>:1' */\r\n      if ((*((const real_T **)ssGetInputPortSignalPtrs(S, 5))[0] == 1.0) && (*((\r\n             const real_T **)ssGetInputPortSignalPtrs(S, 2))[0] == 1.0)) {\r\n        /* Transition: '<S1>:8' */\r\n        ((uint8_T *)ssGetDWork(S, 1))[0] = stateflow_FMU_test_cosim_IN_on;\r\n\r\n        /* Entry 'on': '<S1>:3' */\r\n        _rtB->onState = 1.0;\r\n      } else if ((*((const real_T **)ssGetInputPortSignalPtrs(S, 1))[0] == 1.0) &&\r\n                 (*((const real_T **)ssGetInputPortSignalPtrs(S, 5))[0] == 0.0))\r\n      {\r\n        /* Transition: '<S1>:17' */\r\n        ((uint8_T *)ssGetDWork(S, 1))[0] = stateflow_FMU_test_cosim_IN_off;\r\n\r\n        /* Entry 'off': '<S1>:4' */\r\n      } else {\r\n        _rtB->startState = 1.0;\r\n        _rtB->delayState = 1.0;\r\n      }\r\n      break;\r\n\r\n     default:\r\n      /* During 'wait': '<S1>:5' */\r\n      if ((*((const real_T **)ssGetInputPortSignalPtrs(S, 4))[0] == 1.0) && (*((\r\n             const real_T **)ssGetInputPortSignalPtrs(S, 2))[0] == 0.0)) {\r\n        /* Transition: '<S1>:11' */\r\n        ((uint8_T *)ssGetDWork(S, 1))[0] = stateflow_FMU_test_cosim_IN_on;\r\n\r\n        /* Entry 'on': '<S1>:3' */\r\n        _rtB->onState = 1.0;\r\n      } else if (*((const real_T **)ssGetInputPortSignalPtrs(S, 0))[0] == 1.0) {\r\n        /* Transition: '<S1>:13' */\r\n        ((uint8_T *)ssGetDWork(S, 1))[0] = stateflow_FMU_test_cos_IN_delay;\r\n\r\n        /* Entry 'delay': '<S1>:6' */\r\n      } else {\r\n        _rtB->waitState = 1.0;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<Root>/State Flow FMU Test' */\r\n\r\n  /* Outport: '<Root>/waitState' */\r\n  ((real_T *)ssGetOutputPortSignal(S, 0))[0] = _rtB->waitState;\r\n\r\n  /* Outport: '<Root>/onState' */\r\n  ((real_T *)ssGetOutputPortSignal(S, 1))[0] = _rtB->onState;\r\n\r\n  /* Outport: '<Root>/offState' */\r\n  ((real_T *)ssGetOutputPortSignal(S, 2))[0] = _rtB->offState;\r\n\r\n  /* Outport: '<Root>/delayState' */\r\n  ((real_T *)ssGetOutputPortSignal(S, 3))[0] = _rtB->delayState;\r\n\r\n  /* Outport: '<Root>/queueState' */\r\n  ((real_T *)ssGetOutputPortSignal(S, 4))[0] = _rtB->queueState;\r\n\r\n  /* Outport: '<Root>/startState' */\r\n  ((real_T *)ssGetOutputPortSignal(S, 5))[0] = _rtB->startState;\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\n/* Update for root system: '<Root>' */\r\n#define MDL_UPDATE\r\n\r\nstatic void mdlUpdate(SimStruct *S, int_T tid)\r\n{\r\n  UNUSED_PARAMETER(tid);\r\n}\r\n\r\n/* Termination for root system: '<Root>' */\r\nstatic void mdlTerminate(SimStruct *S)\r\n{\r\n\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n\r\n  if (ssGetUserData(S) != (NULL) ) {\r\n    rt_FREE(ssGetLocalBlockIO(S));\r\n  }\r\n\r\n  rt_FREE(ssGetUserData(S));\r\n\r\n#endif\r\n\r\n}\r\n\r\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\r\n#include \"stateflow_FMU_test_cosim_mid.h\"\r\n#endif\r\n\r\n/* Function to initialize sizes. */\r\nstatic void mdlInitializeSizes(SimStruct *S)\r\n{\r\n  ssSetNumSampleTimes(S, 1);           /* Number of sample times */\r\n  ssSetNumContStates(S, 0);            /* Number of continuous states */\r\n  ssSetNumNonsampledZCs(S, 0);         /* Number of nonsampled ZCs */\r\n\r\n  /* Number of output ports */\r\n  if (!ssSetNumOutputPorts(S, 6))\r\n    return;\r\n\r\n  /* outport number: 0 */\r\n  if (!ssSetOutputPortVectorDimension(S, 0, 1))\r\n    return;\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 0, SS_DOUBLE);\r\n  }\r\n\r\n  ssSetOutputPortOptimOpts(S, 0, SS_REUSABLE_AND_LOCAL);\r\n\r\n  /* outport number: 1 */\r\n  if (!ssSetOutputPortVectorDimension(S, 1, 1))\r\n    return;\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 1, SS_DOUBLE);\r\n  }\r\n\r\n  ssSetOutputPortOptimOpts(S, 1, SS_REUSABLE_AND_LOCAL);\r\n\r\n  /* outport number: 2 */\r\n  if (!ssSetOutputPortVectorDimension(S, 2, 1))\r\n    return;\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 2, SS_DOUBLE);\r\n  }\r\n\r\n  ssSetOutputPortOptimOpts(S, 2, SS_REUSABLE_AND_LOCAL);\r\n\r\n  /* outport number: 3 */\r\n  if (!ssSetOutputPortVectorDimension(S, 3, 1))\r\n    return;\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 3, SS_DOUBLE);\r\n  }\r\n\r\n  ssSetOutputPortOptimOpts(S, 3, SS_REUSABLE_AND_LOCAL);\r\n\r\n  /* outport number: 4 */\r\n  if (!ssSetOutputPortVectorDimension(S, 4, 1))\r\n    return;\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 4, SS_DOUBLE);\r\n  }\r\n\r\n  ssSetOutputPortOptimOpts(S, 4, SS_REUSABLE_AND_LOCAL);\r\n\r\n  /* outport number: 5 */\r\n  if (!ssSetOutputPortVectorDimension(S, 5, 1))\r\n    return;\r\n  if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n    ssSetOutputPortDataType(S, 5, SS_DOUBLE);\r\n  }\r\n\r\n  ssSetOutputPortOptimOpts(S, 5, SS_REUSABLE_AND_LOCAL);\r\n\r\n  /* Number of input ports */\r\n  if (!ssSetNumInputPorts(S, 6))\r\n    return;\r\n\r\n  /* inport number: 0 */\r\n  {\r\n    if (!ssSetInputPortVectorDimension(S, 0, 1))\r\n      return;\r\n    if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n      ssSetInputPortDataType(S, 0, SS_DOUBLE);\r\n    }\r\n\r\n    ssSetInputPortDirectFeedThrough(S, 0, 1);\r\n    ssSetInputPortOverWritable(S, 0, 0);\r\n    ssSetInputPortOptimOpts(S, 0, SS_NOT_REUSABLE_AND_GLOBAL);\r\n  }\r\n\r\n  /* inport number: 1 */\r\n  {\r\n    if (!ssSetInputPortVectorDimension(S, 1, 1))\r\n      return;\r\n    if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n      ssSetInputPortDataType(S, 1, SS_DOUBLE);\r\n    }\r\n\r\n    ssSetInputPortDirectFeedThrough(S, 1, 1);\r\n    ssSetInputPortOverWritable(S, 1, 0);\r\n    ssSetInputPortOptimOpts(S, 1, SS_NOT_REUSABLE_AND_GLOBAL);\r\n  }\r\n\r\n  /* inport number: 2 */\r\n  {\r\n    if (!ssSetInputPortVectorDimension(S, 2, 1))\r\n      return;\r\n    if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n      ssSetInputPortDataType(S, 2, SS_DOUBLE);\r\n    }\r\n\r\n    ssSetInputPortDirectFeedThrough(S, 2, 1);\r\n    ssSetInputPortOverWritable(S, 2, 0);\r\n    ssSetInputPortOptimOpts(S, 2, SS_NOT_REUSABLE_AND_GLOBAL);\r\n  }\r\n\r\n  /* inport number: 3 */\r\n  {\r\n    if (!ssSetInputPortVectorDimension(S, 3, 1))\r\n      return;\r\n    if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n      ssSetInputPortDataType(S, 3, SS_DOUBLE);\r\n    }\r\n\r\n    ssSetInputPortDirectFeedThrough(S, 3, 1);\r\n    ssSetInputPortOverWritable(S, 3, 0);\r\n    ssSetInputPortOptimOpts(S, 3, SS_NOT_REUSABLE_AND_GLOBAL);\r\n  }\r\n\r\n  /* inport number: 4 */\r\n  {\r\n    if (!ssSetInputPortVectorDimension(S, 4, 1))\r\n      return;\r\n    if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n      ssSetInputPortDataType(S, 4, SS_DOUBLE);\r\n    }\r\n\r\n    ssSetInputPortDirectFeedThrough(S, 4, 1);\r\n    ssSetInputPortOverWritable(S, 4, 0);\r\n    ssSetInputPortOptimOpts(S, 4, SS_NOT_REUSABLE_AND_GLOBAL);\r\n  }\r\n\r\n  /* inport number: 5 */\r\n  {\r\n    if (!ssSetInputPortVectorDimension(S, 5, 1))\r\n      return;\r\n    if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {\r\n      ssSetInputPortDataType(S, 5, SS_DOUBLE);\r\n    }\r\n\r\n    ssSetInputPortDirectFeedThrough(S, 5, 1);\r\n    ssSetInputPortOverWritable(S, 5, 0);\r\n    ssSetInputPortOptimOpts(S, 5, SS_NOT_REUSABLE_AND_GLOBAL);\r\n  }\r\n\r\n  ssSetRTWGeneratedSFcn(S, 1);         /* Generated S-function */\r\n\r\n  /* DWork */\r\n  if (!ssSetNumDWork(S, 2)) {\r\n    return;\r\n  }\r\n\r\n  /* '<Root>/State Flow FMU Test': DWORK1 */\r\n  ssSetDWorkName(S, 0, \"DWORK0\");\r\n  ssSetDWorkWidth(S, 0, 1);\r\n  ssSetDWorkDataType(S, 0, SS_UINT8);\r\n\r\n  /* '<Root>/State Flow FMU Test': DWORK2 */\r\n  ssSetDWorkName(S, 1, \"DWORK1\");\r\n  ssSetDWorkWidth(S, 1, 1);\r\n  ssSetDWorkDataType(S, 1, SS_UINT8);\r\n\r\n  /* Tunable Parameters */\r\n  ssSetNumSFcnParams(S, 0);\r\n\r\n  /* Number of expected parameters */\r\n#if defined(MATLAB_MEX_FILE)\r\n\r\n  if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {\r\n\r\n#if defined(MDL_CHECK_PARAMETERS)\r\n\r\n    mdlCheckParameters(S);\r\n\r\n#endif                                 /* MDL_CHECK_PARAMETERS */\r\n\r\n    if (ssGetErrorStatus(S) != (NULL) ) {\r\n      return;\r\n    }\r\n  } else {\r\n    return;                /* Parameter mismatch will be reported by Simulink */\r\n  }\r\n\r\n#endif                                 /* MATLAB_MEX_FILE */\r\n\r\n  /* Options */\r\n  ssSetOptions(S, (SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE |\r\n                   SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME ));\r\n\r\n#if SS_SFCN_FOR_SIM\r\n\r\n  {\r\n    ssSupportsMultipleExecInstances(S, true);\r\n    ssHasStateInsideForEachSS(S, false);\r\n    ssSetModelReferenceSampleTimeInheritanceRule(S,\r\n      USE_DEFAULT_FOR_DISCRETE_INHERITANCE);\r\n  }\r\n\r\n#endif\r\n\r\n}\r\n\r\n/* Function to initialize sample times. */\r\nstatic void mdlInitializeSampleTimes(SimStruct *S)\r\n{\r\n  ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);\r\n  ssSetOffsetTime(S, 0, 0.0);\r\n}\r\n\r\n#if defined(MATLAB_MEX_FILE)\r\n#include \"fixedpoint.c\"\r\n#include \"simulink.c\"\r\n#else\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME                stateflow_FMU_test_cosim_sf\r\n#include \"cg_sfun.h\"\r\n#endif                                 /* defined(MATLAB_MEX_FILE) */\r\n"},{"name":"stateflow_FMU_test_cosim_sf.h","type":"header","group":"model","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * stateflow_FMU_test_cosim_sf.h\r\n *\r\n * Code generation for model \"stateflow_FMU_test_cosim_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Wed Jun  1 19:09:22 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_stateflow_FMU_test_cosim_sf_h_\r\n#define RTW_HEADER_stateflow_FMU_test_cosim_sf_h_\r\n#include <string.h>\r\n#include <stddef.h>\r\n#ifndef stateflow_FMU_test_cosim_sf_COMMON_INCLUDES_\r\n#define stateflow_FMU_test_cosim_sf_COMMON_INCLUDES_\r\n#include <stdlib.h>\r\n#define S_FUNCTION_NAME                stateflow_FMU_test_cosim_sf\r\n#define S_FUNCTION_LEVEL               2\r\n#ifndef RTW_GENERATED_S_FUNCTION\r\n#define RTW_GENERATED_S_FUNCTION\r\n#endif\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#if !defined(MATLAB_MEX_FILE)\r\n#include \"rt_matrx.h\"\r\n#endif\r\n\r\n#if !defined(RTW_SFUNCTION_DEFINES)\r\n#define RTW_SFUNCTION_DEFINES\r\n\r\ntypedef struct {\r\n  void *blockIO;\r\n  void *defaultParam;\r\n  void *nonContDerivSig;\r\n} LocalS;\r\n\r\n#define ssSetLocalBlockIO(S, io)       ((LocalS *)ssGetUserData(S))->blockIO = ((void *)(io))\r\n#define ssGetLocalBlockIO(S)           ((LocalS *)ssGetUserData(S))->blockIO\r\n#define ssSetLocalDefaultParam(S, paramVector) ((LocalS *)ssGetUserData(S))->defaultParam = (paramVector)\r\n#define ssGetLocalDefaultParam(S)      ((LocalS *)ssGetUserData(S))->defaultParam\r\n#define ssSetLocalNonContDerivSig(S, pSig) ((LocalS *)ssGetUserData(S))->nonContDerivSig = (pSig)\r\n#define ssGetLocalNonContDerivSig(S)   ((LocalS *)ssGetUserData(S))->nonContDerivSig\r\n#endif\r\n#endif                        /* stateflow_FMU_test_cosim_sf_COMMON_INCLUDES_ */\r\n\r\n#include \"stateflow_FMU_test_cosim_sf_types.h\"\r\n\r\n/* Shared type includes */\r\n#include \"multiword_types.h\"\r\n#include \"rtGetNaN.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"rt_defines.h\"\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T waitState;                    /* '<Root>/State Flow FMU Test' */\r\n  real_T onState;                      /* '<Root>/State Flow FMU Test' */\r\n  real_T offState;                     /* '<Root>/State Flow FMU Test' */\r\n  real_T delayState;                   /* '<Root>/State Flow FMU Test' */\r\n  real_T queueState;                   /* '<Root>/State Flow FMU Test' */\r\n  real_T startState;                   /* '<Root>/State Flow FMU Test' */\r\n} B_stateflow_FMU_test_cosim_T;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real_T *delayCode;                   /* '<Root>/delayCode' */\r\n  real_T *offCode;                     /* '<Root>/offCode' */\r\n  real_T *onCode;                      /* '<Root>/onCode' */\r\n  real_T *queueCode;                   /* '<Root>/queueCode' */\r\n  real_T *waitCode;                    /* '<Root>/waitCode' */\r\n  real_T *startCode;                   /* '<Root>/startCode' */\r\n} ExternalUPtrs_stateflow_FMU_test_cosim_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T *waitState;                   /* '<Root>/waitState' */\r\n  real_T *onState;                     /* '<Root>/onState' */\r\n  real_T *offState;                    /* '<Root>/offState' */\r\n  real_T *delayState;                  /* '<Root>/delayState' */\r\n  real_T *queueState;                  /* '<Root>/queueState' */\r\n  real_T *startState;                  /* '<Root>/startState' */\r\n} ExtY_stateflow_FMU_test_cosim_T;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'stateflow_FMU_test_cosim_sf'\r\n * '<S1>'   : 'stateflow_FMU_test_cosim/State Flow FMU Test'\r\n */\r\n#endif                           /* RTW_HEADER_stateflow_FMU_test_cosim_sf_h_ */\r\n"},{"name":"stateflow_FMU_test_cosim_sf_private.h","type":"header","group":"model","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * stateflow_FMU_test_cosim_sf_private.h\r\n *\r\n * Code generation for model \"stateflow_FMU_test_cosim_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Wed Jun  1 19:09:22 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_stateflow_FMU_test_cosim_sf_private_h_\r\n#define RTW_HEADER_stateflow_FMU_test_cosim_sf_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n#if !defined(ss_VALIDATE_MEMORY)\r\n#define ss_VALIDATE_MEMORY(S, ptr)     if(!(ptr)) {\\\r\n ssSetErrorStatus(S, RT_MEMORY_ALLOCATION_ERROR);\\\r\n }\r\n#endif\r\n\r\n#if !defined(rt_FREE)\r\n#if !defined(_WIN32)\r\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\r\n free((ptr));\\\r\n (ptr) = (NULL);\\\r\n }\r\n#else\r\n\r\n/* Visual and other windows compilers declare free without const */\r\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\r\n free((void *)(ptr));\\\r\n (ptr) = (NULL);\\\r\n }\r\n#endif\r\n#endif\r\n#endif                   /* RTW_HEADER_stateflow_FMU_test_cosim_sf_private_h_ */\r\n"},{"name":"stateflow_FMU_test_cosim_sf_types.h","type":"header","group":"model","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Model files","code":"/*\r\n * stateflow_FMU_test_cosim_sf_types.h\r\n *\r\n * Code generation for model \"stateflow_FMU_test_cosim_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Wed Jun  1 19:09:22 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_stateflow_FMU_test_cosim_sf_types_h_\r\n#define RTW_HEADER_stateflow_FMU_test_cosim_sf_types_h_\r\n\r\n/* Model Code Variants */\r\n#endif                     /* RTW_HEADER_stateflow_FMU_test_cosim_sf_types_h_ */\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Code generation for model \"stateflow_FMU_test_cosim_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Wed Jun  1 19:09:22 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int64_T chunk_T;\r\ntypedef uint64_T uchunk_T;\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long long longlong_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetInf.c\r\n *\r\n * Code generation for model \"stateflow_FMU_test_cosim_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Wed Jun  1 19:09:22 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, Inf\r\n */\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rtGetInf.h\r\n    *\r\n        * Code generation for model \"stateflow_FMU_test_cosim_sf\".\r\n    *\r\n    * Model version              : 1.5\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Wed Jun  1 19:09:22 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rtGetInf_h_\r\n    #define RTW_HEADER_rtGetInf_h_\r\n\r\n\r\n        \r\n\r\n    \r\n#include <stddef.h>\r\n    #include \"rtwtypes.h\"\r\n    #include \"rt_nonfinite.h\"\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        \r\n        extern real_T rtGetInf(void);\r\n            extern real32_T rtGetInfF(void);\r\n            extern real_T rtGetMinusInf(void);\r\n            extern real32_T rtGetMinusInfF(void);\r\n        \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rtGetInf_h_ */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetNaN.c\r\n *\r\n * Code generation for model \"stateflow_FMU_test_cosim_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Wed Jun  1 19:09:22 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, NaN\r\n */\r\n#include \"rtGetNaN.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\r\n        tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  uint16_T one = 1U;\r\n  enum {\r\n    LittleEndian,\r\n    BigEndian\r\n  } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n  switch (machByteOrder) {\r\n   case LittleEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0xFFC00000U;\r\n      break;\r\n    }\r\n\r\n   case BigEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0x7FFFFFFFU;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return nanF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rtGetNaN.h\r\n    *\r\n        * Code generation for model \"stateflow_FMU_test_cosim_sf\".\r\n    *\r\n    * Model version              : 1.5\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Wed Jun  1 19:09:22 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rtGetNaN_h_\r\n    #define RTW_HEADER_rtGetNaN_h_\r\n\r\n\r\n        \r\n\r\n    \r\n#include <stddef.h>\r\n    #include \"rtwtypes.h\"\r\n    #include \"rt_nonfinite.h\"\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        \r\n        extern real_T rtGetNaN(void);\r\n            extern real32_T rtGetNaNF(void);\r\n        \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rtGetNaN_h_ */\r\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rt_defines.h\r\n    *\r\n        * Code generation for model \"stateflow_FMU_test_cosim_sf\".\r\n    *\r\n    * Model version              : 1.5\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Wed Jun  1 19:09:22 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rt_defines_h_\r\n    #define RTW_HEADER_rt_defines_h_\r\n\r\n\r\n        \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    /*===========*\r\n    * Constants *\r\n    *===========*/\r\n\r\n    #define RT_PI          3.14159265358979323846\r\n    #define RT_PIF         3.1415927F\r\n    #define RT_LN_10       2.30258509299404568402\r\n    #define RT_LN_10F      2.3025851F\r\n    #define RT_LOG10E      0.43429448190325182765\r\n    #define RT_LOG10EF     0.43429449F\r\n    #define RT_E           2.7182818284590452354\r\n    #define RT_EF          2.7182817F\r\n\r\n    /*\r\n    * UNUSED_PARAMETER(x)\r\n    *   Used to specify that a function parameter (argument) is required but not\r\n    *   accessed by the function body.\r\n    */\r\n    #ifndef UNUSED_PARAMETER\r\n    #if defined(__LCC__)\r\n    #define UNUSED_PARAMETER(x)  /* do nothing */\r\n    #else\r\n    /*\r\n    * This is the semi-ANSI standard way of indicating that an\r\n    * unused function parameter is required.\r\n    */\r\n    #define UNUSED_PARAMETER(x) (void) (x)\r\n    #endif\r\n    #endif\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rt_defines_h_ */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.c\r\n *\r\n * Code generation for model \"stateflow_FMU_test_cosim_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Wed Jun  1 19:09:22 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finites,\r\n *      (Inf, NaN and -Inf).\r\n */\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"\r\n\r\n        /*\r\n    * rt_nonfinite.h\r\n    *\r\n        * Code generation for model \"stateflow_FMU_test_cosim_sf\".\r\n    *\r\n    * Model version              : 1.5\r\n    * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n        * C source code generated on : Wed Jun  1 19:09:22 2022\r\n * \r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n    */\r\n\r\n\r\n    #ifndef RTW_HEADER_rt_nonfinite_h_\r\n    #define RTW_HEADER_rt_nonfinite_h_\r\n\r\n\r\n        \r\n\r\n    \r\n#include <stddef.h>\r\n    #include \"rtwtypes.h\"\r\n\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n        \r\n    \r\n\r\n\r\n    extern real_T rtInf;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real_T rtMinusInf;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real_T rtNaN;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real32_T rtInfF;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real32_T rtMinusInfF;\r\n\r\n\r\n    \r\n\r\n\r\n    extern real32_T rtNaNF;\r\n\r\n\r\n\r\n        extern void rt_InitInfAndNaN(size_t realSize);\r\n            extern boolean_T rtIsInf(real_T value);\r\n            extern boolean_T rtIsInfF(real32_T value);\r\n            extern boolean_T rtIsNaN(real_T value);\r\n            extern boolean_T rtIsNaNF(real32_T value);\r\n    \r\n    typedef struct  {\r\n    struct {\r\n        uint32_T wordH;\r\n        uint32_T wordL;\r\n    } words;\r\n    } BigEndianIEEEDouble;\r\n\r\n    typedef struct  {\r\n    struct {\r\n        uint32_T wordL;\r\n        uint32_T wordH;\r\n    } words;\r\n    } LittleEndianIEEEDouble;\r\n\r\n    typedef struct  {\r\n    union {\r\n        real32_T wordLreal;\r\n        uint32_T wordLuint;\r\n    } wordL;\r\n    } IEEESingle;\r\n\r\n    \r\n\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n\r\n    #endif /* RTW_HEADER_rt_nonfinite_h_ */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Code generation for model \"stateflow_FMU_test_cosim_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Wed Jun  1 19:09:22 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n#ifndef INT64_T\r\n#define INT64_T\r\n\r\ntypedef long long int64_T;\r\n\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#endif\r\n\r\n#ifndef UINT64_T\r\n#define UINT64_T\r\n\r\ntypedef unsigned long long uint64_T;\r\n\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n#endif\r\n\r\n/*===========================================================================*\r\n * Additional complex number type definitions                                           *\r\n *===========================================================================*/\r\n#ifndef CINT64_T\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#endif\r\n\r\n#ifndef CUINT64_T\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"stateflow_FMU_test_cosim_mid.h","type":"header","group":"interface","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Interface files","code":"/*\r\n * stateflow_FMU_test_cosim_mid.h\r\n *\r\n * Code generation for model \"stateflow_FMU_test_cosim_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Wed Jun  1 19:09:22 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n *\r\n * SOURCES: stateflow_FMU_test_cosim_sf.c\r\n */\r\n\r\n#include \"simstruc.h\"\r\n#include \"stateflow_FMU_test_cosim_sf.h\"\r\n#if defined(MATLAB_MEX_FILE) || defined(RT_MALLOC)\r\n\r\nstatic int_T RegNumInputPorts(SimStruct *S, int_T nInputPorts)\r\n{\r\n  _ssSetNumInputPorts(S,nInputPorts);\r\n  return true;\r\n}\r\n\r\nstatic int_T RegNumOutputPorts(SimStruct *S, int_T nOutputPorts)\r\n{\r\n  _ssSetNumOutputPorts(S,nOutputPorts);\r\n  return true;\r\n}\r\n\r\nstatic int_T FcnSetErrorStatus(const SimStruct *S, DTypeId arg2)\r\n{\r\n  static char msg[256];\r\n  if (strlen(ssGetModelName(S)) < 128) {\r\n    sprintf(msg,\r\n            \"S-function %s does not have a tlc file. It cannot use macros that access regDataType field in simstruct.\",\r\n            ssGetModelName(S));\r\n  } else {\r\n    sprintf(msg,\r\n            \"A S-function does not have a tlc file. It cannot use macros that access regDataType field in simstruct.\");\r\n  }\r\n\r\n  ssSetErrorStatus(S, msg);\r\n  UNUSED_PARAMETER(arg2);\r\n  return 0;\r\n}\r\n\r\nstatic void * FcnSetErrorStatusWithReturnPtr(const SimStruct *S, DTypeId arg2)\r\n{\r\n  FcnSetErrorStatus(S,0);\r\n  UNUSED_PARAMETER(arg2);\r\n  return 0;\r\n}\r\n\r\nstatic int_T FcnSetErrorStatusWithArgPtr(const SimStruct *S, const void* arg2)\r\n{\r\n  FcnSetErrorStatus(S,0);\r\n  UNUSED_PARAMETER(arg2);\r\n  return 0;\r\n}\r\n\r\n#endif\r\n\r\n/* Instance data for model: stateflow_FMU_test_cosim */\r\nvoid *stateflow_FMU_test_cosim_malloc(SimStruct *rts)\r\n{\r\n  /* Local SimStruct for the generated S-Function */\r\n  LocalS *lS = (LocalS *) malloc(sizeof(LocalS));\r\n  ss_VALIDATE_MEMORY(rts,lS);\r\n  (void) memset((char *) lS, 0,\r\n                sizeof(LocalS));\r\n  ssSetUserData(rts, lS);\r\n\r\n  /* block I/O */\r\n  {\r\n    void *b = malloc(sizeof(B_stateflow_FMU_test_cosim_T));\r\n    ss_VALIDATE_MEMORY(rts,b);\r\n    ssSetLocalBlockIO(rts, b);\r\n    (void) memset(b, 0,\r\n                  sizeof(B_stateflow_FMU_test_cosim_T));\r\n  }\r\n\r\n  /* model checksums */\r\n  ssSetChecksumVal(rts, 0, 374118774U);\r\n  ssSetChecksumVal(rts, 1, 475945049U);\r\n  ssSetChecksumVal(rts, 2, 3051879824U);\r\n  ssSetChecksumVal(rts, 3, 1139358516U);\r\n  return (NULL);\r\n}\r\n"},{"name":"stateflow_FMU_test_cosim_sid.h","type":"header","group":"interface","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Interface files","code":"/*\r\n * stateflow_FMU_test_cosim_sid.h\r\n *\r\n * Code generation for model \"stateflow_FMU_test_cosim_sf\".\r\n *\r\n * Model version              : 1.5\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Wed Jun  1 19:09:22 2022\r\n *\r\n * Target selection: rtwsfcnfmi.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n *\r\n * SOURCES: stateflow_FMU_test_cosim_sf.c\r\n */\r\n\r\n/* statically allocated instance data for model: stateflow_FMU_test_cosim */\r\n{\r\n  {\r\n    /* Local SimStruct for the generated S-Function */\r\n    static LocalS slS;\r\n    LocalS *lS = &slS;\r\n    ssSetUserData(rts, lS);\r\n\r\n    /* block I/O */\r\n    {\r\n      static B_stateflow_FMU_test_cosim_T sfcnB;\r\n      void *b = (real_T *) &sfcnB;\r\n      ssSetLocalBlockIO(rts, b);\r\n      (void) memset(b, 0,\r\n                    sizeof(B_stateflow_FMU_test_cosim_T));\r\n    }\r\n\r\n    /* model checksums */\r\n    ssSetChecksumVal(rts, 0, 374118774U);\r\n    ssSetChecksumVal(rts, 1, 475945049U);\r\n    ssSetChecksumVal(rts, 2, 3051879824U);\r\n    ssSetChecksumVal(rts, 3, 1139358516U);\r\n  }\r\n}\r\n"},{"name":"model_interface.c","type":"source","group":"legacy","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Other files","code":"#include \"stateflow_FMU_test_cosim_sf.h\"\r\n#include \"model_interface.h\"\r\n\r\nsize_t getCGTypeSize(DTypeId typeIndex)\r\n{\r\n  switch (typeIndex) {\r\n   case 0:\r\n    return 8;                          /* real_T */\r\n\r\n   case 1:\r\n    return 4;                          /* real32_T */\r\n\r\n   case 2:\r\n    return 1;                          /* int8_T */\r\n\r\n   case 3:\r\n    return 1;                          /* uint8_T */\r\n\r\n   case 4:\r\n    return 2;                          /* int16_T */\r\n\r\n   case 5:\r\n    return 2;                          /* uint16_T */\r\n\r\n   case 6:\r\n    return 4;                          /* int32_T */\r\n\r\n   case 7:\r\n    return 4;                          /* uint32_T */\r\n\r\n   case 8:\r\n    return 1;                          /* boolean_T */\r\n\r\n   case 9:\r\n    return 0;                          /* fcn_call_T */\r\n\r\n   case 10:\r\n    return 4;                          /* int_T */\r\n\r\n   case 11:\r\n    return 8;                          /* pointer_T */\r\n\r\n   case 12:\r\n    return 8;                          /* action_T */\r\n\r\n   case 13:\r\n    return 8;                          /* timer_uint32_pair_T */\r\n\r\n   case 14:\r\n    return 8;                          /* physical_connection */\r\n\r\n   default:\r\n    return 0;                          /* unknown type */\r\n  }\r\n}\r\n\r\nvoid initializeModelVariables(SimStruct* S, ModelVariable modelVariables[])\r\n{\r\n  modelVariables[0].dtypeID = 0;\r\n  modelVariables[0].size = 0;\r\n  modelVariables[0].address = &((*((real_T **)ssGetInputPortSignalPtrs(S, 0))[0]));\r\n  modelVariables[1].dtypeID = 0;\r\n  modelVariables[1].size = 0;\r\n  modelVariables[1].address = &((*((real_T **)ssGetInputPortSignalPtrs(S, 1))[0]));\r\n  modelVariables[2].dtypeID = 0;\r\n  modelVariables[2].size = 0;\r\n  modelVariables[2].address = &((*((real_T **)ssGetInputPortSignalPtrs(S, 2))[0]));\r\n  modelVariables[3].dtypeID = 0;\r\n  modelVariables[3].size = 0;\r\n  modelVariables[3].address = &((*((real_T **)ssGetInputPortSignalPtrs(S, 3))[0]));\r\n  modelVariables[4].dtypeID = 0;\r\n  modelVariables[4].size = 0;\r\n  modelVariables[4].address = &((*((real_T **)ssGetInputPortSignalPtrs(S, 4))[0]));\r\n  modelVariables[5].dtypeID = 0;\r\n  modelVariables[5].size = 0;\r\n  modelVariables[5].address = &((*((real_T **)ssGetInputPortSignalPtrs(S, 5))[0]));\r\n  modelVariables[6].dtypeID = 0;\r\n  modelVariables[6].size = 0;\r\n  modelVariables[6].address = &(((real_T *)ssGetOutputPortSignal(S, 0))[0]);\r\n  modelVariables[7].dtypeID = 0;\r\n  modelVariables[7].size = 0;\r\n  modelVariables[7].address = &(((real_T *)ssGetOutputPortSignal(S, 1))[0]);\r\n  modelVariables[8].dtypeID = 0;\r\n  modelVariables[8].size = 0;\r\n  modelVariables[8].address = &(((real_T *)ssGetOutputPortSignal(S, 2))[0]);\r\n  modelVariables[9].dtypeID = 0;\r\n  modelVariables[9].size = 0;\r\n  modelVariables[9].address = &(((real_T *)ssGetOutputPortSignal(S, 3))[0]);\r\n  modelVariables[10].dtypeID = 0;\r\n  modelVariables[10].size = 0;\r\n  modelVariables[10].address = &(((real_T *)ssGetOutputPortSignal(S, 4))[0]);\r\n  modelVariables[11].dtypeID = 0;\r\n  modelVariables[11].size = 0;\r\n  modelVariables[11].address = &(((real_T *)ssGetOutputPortSignal(S, 5))[0]);\r\n  modelVariables[12].dtypeID = 0;\r\n  modelVariables[12].size = 0;\r\n  modelVariables[12].address = &(((B_stateflow_FMU_test_cosim_T *)\r\n    ssGetLocalBlockIO(S))->waitState);\r\n  modelVariables[13].dtypeID = 0;\r\n  modelVariables[13].size = 0;\r\n  modelVariables[13].address = &(((B_stateflow_FMU_test_cosim_T *)\r\n    ssGetLocalBlockIO(S))->onState);\r\n  modelVariables[14].dtypeID = 0;\r\n  modelVariables[14].size = 0;\r\n  modelVariables[14].address = &(((B_stateflow_FMU_test_cosim_T *)\r\n    ssGetLocalBlockIO(S))->offState);\r\n  modelVariables[15].dtypeID = 0;\r\n  modelVariables[15].size = 0;\r\n  modelVariables[15].address = &(((B_stateflow_FMU_test_cosim_T *)\r\n    ssGetLocalBlockIO(S))->delayState);\r\n  modelVariables[16].dtypeID = 0;\r\n  modelVariables[16].size = 0;\r\n  modelVariables[16].address = &(((B_stateflow_FMU_test_cosim_T *)\r\n    ssGetLocalBlockIO(S))->queueState);\r\n  modelVariables[17].dtypeID = 0;\r\n  modelVariables[17].size = 0;\r\n  modelVariables[17].address = &(((B_stateflow_FMU_test_cosim_T *)\r\n    ssGetLocalBlockIO(S))->startState);\r\n}\r\n"},{"name":"model_interface.h","type":"header","group":"other","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Other files","code":"#ifndef model_interface_h\r\n#define model_interface_h\r\n#include \"tmwtypes.h\"\r\n#define N_MODEL_VARIABLES              19\r\n\r\ntypedef struct {\r\n  BuiltInDTypeId dtypeID;\r\n  size_t size;\r\n  void* address;\r\n} ModelVariable;\r\n\r\nsize_t getCGTypeSize(DTypeId typeIndex);\r\nvoid initializeModelVariables(SimStruct* S, ModelVariable modelVariables[]);\r\n\r\n#endif                                 /* model_interface_h */\r\n"},{"name":"sfcn_fmi.c","type":"source","group":"legacy","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Other files","code":"/*\r\n * sfcn_fmi.c\r\n *\r\n *  Model-specific code required to build FMI executable\r\n *  from Simulink model \"stateflow_FMU_test_cosim\".\r\n *\r\n * Generated on : Wed Jun  1 19:09:21 2022\r\n */\r\n\r\n#include <stddef.h>\r\n#if defined(MATLAB_MEX_FILE)\r\n#include \"mex.h\"\r\n#undef mexCallMATLAB\r\n#define mexCallMATLAB                  sfcn_fmi_load_mex\r\n#else\r\n\r\n/* Code to enable global tunable parameters in stand-alone mode */\r\n#define RTW_GENERATED_SFCN_TUNABLE_PRMS_stateflow_FMU_test_cosim_sf\r\n#define RTW_GENERATED_S_FUNCTION\r\n#include \"simstruc.h\"\r\n#include \"fixedpoint.h\"\r\n#if defined (_MSC_VER)\r\n\r\n#pragma warning(disable:4005)\r\n\r\n#endif\r\n\r\n#define mxGetData(x)                   x\r\n#define ssFxpSetU32BitRegionCompliant(S, v)\r\n#include \"rt_nonfinite.c\"\r\n#endif\r\n\r\n/* Include Simulink Coder-generated model code */\r\n#include \"stateflow_FMU_test_cosim_sf.c\"\r\n\r\n/* Register model callback routines in SimStruct */\r\nvoid sfcn_fmi_registerMdlCallbacks_(SimStruct*S)\r\n{\r\n  ssSetmdlInitializeSizes(S, mdlInitializeSizes);\r\n  ssSetmdlInitializeSampleTimes(S, mdlInitializeSampleTimes);\r\n\r\n#if defined(MDL_INITIALIZE_CONDITIONS)\r\n\r\n  ssSetmdlInitializeConditions(S, mdlInitializeConditions);\r\n\r\n#else\r\n\r\n  ssSetmdlInitializeConditions(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined(MDL_START)\r\n\r\n  ssSetmdlStart(S, mdlStart);\r\n\r\n#else\r\n\r\n  ssSetmdlStart(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined(RTW_GENERATED_ENABLE)\r\n\r\n  _ssSetRTWGeneratedEnable(S, mdlEnable);\r\n\r\n#else\r\n\r\n  _ssSetRTWGeneratedEnable(S, NULL);\r\n\r\n#endif\r\n\r\n  ssSetmdlOutputs(S,mdlOutputs);\r\n\r\n#if defined(MDL_ZERO_CROSSINGS)\r\n\r\n  ssSetmdlZeroCrossings(S, mdlZeroCrossings);\r\n\r\n#else\r\n\r\n  ssSetmdlZeroCrossings(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined(MDL_DERIVATIVES)\r\n\r\n  ssSetmdlDerivatives(S, mdlDerivatives);\r\n\r\n#else\r\n\r\n  ssSetmdlDerivatives(S, NULL);\r\n\r\n#endif\r\n\r\n#if defined (MDL_UPDATE)\r\n\r\n  ssSetmdlUpdate(S, mdlUpdate);\r\n\r\n#else\r\n\r\n  ssSetmdlUpdate(S, NULL);\r\n\r\n#endif\r\n\r\n  ssSetmdlTerminate(S, mdlTerminate);\r\n}\r\n\r\n/* Register SolverInfo model method pointers */\r\n\r\n/* Empty callback for use as mdlProjection in ODE solver */\r\nstatic void mdlNoOpFunc(SimStruct *S)\r\n{\r\n  return;\r\n}\r\n\r\nvoid sfcn_fmi_registerRTModelCallbacks_(SimStruct*S)\r\n{\r\n\r\n#if defined(MDL_DERIVATIVES)\r\n\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmDervisFcn = (rtMdlDerivativesFcn)\r\n    mdlDerivatives;\r\n\r\n#else\r\n\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmDervisFcn = (rtMdlProjectionFcn)\r\n    mdlNoOpFunc;\r\n\r\n#endif\r\n\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmProjectionFcn =\r\n    (rtMdlProjectionFcn) mdlNoOpFunc;\r\n  S->mdlInfo->solverInfo->modelMethodsPtr->rtmOutputsFcn = (rtMdlOutputsFcn)\r\n    mdlOutputs;\r\n}\r\n\r\n/* Copy parameter values to S-function mxArrays */\r\nvoid sfcn_fmi_copyToSFcnParams_(SimStruct* S)\r\n{\r\n  return;                /* No parameters in model (probably due to inlining) */\r\n}\r\n\r\n/* Handle mxArrays for global tunable parameters */\r\nvoid sfcn_fmi_mxGlobalTunable_(SimStruct* S, int_T create, int_T update)\r\n{\r\n  return;                         /* no global tunable parameters as mxArrays */\r\n}\r\n"},{"name":"sfcn_fmi.h","type":"header","group":"other","path":"F:\\GitHubRepos\\stateflow_FMU_test\\stateflow_FMU_test_cosim_sfcn_rtw_fmi","tag":"","groupDisplay":"Other files","code":"/*\r\n * Model-specific defintions for \"stateflow_FMU_test_cosim\"\r\n *\r\n * Generated on : Wed Jun  1 19:09:21 2022\r\n */\r\n\r\n#pragma once\r\n\r\n#include \"simstruc.h\"\r\n#define MODEL_GUID                     \"{d7aaef05-833b-4664-8d4f-4787100c1e6a}\"\r\n\r\n/* Solver settings selected in Simulink */\r\n#define SFCN_FMI_IS_VARIABLE_STEP_SOLVER 0\r\n#define SFCN_FMI_FIXED_STEP_SIZE       0.1\r\n#define SFCN_FMI_IS_MT                 0\r\n#define SFCN_FMI_EXTRAPOLATION_ORDER   -1\r\n#define SFCN_FMI_NEWTON_ITER           -1\r\n\r\n/* Model sizes */\r\n#define SFCN_FMI_ZC_LENGTH             0\r\n\r\n/* Model identifier */\r\n#define SFCN_FMI_MODEL_IDENTIFIER      \"stateflow_FMU_test_cosim\"\r\n\r\n/* Loading of MEX binaries, path to MATLAB bin */\r\n#define SFCN_FMI_LOAD_MEX              1\r\n#define SFCN_FMI_MATLAB_BIN            \"D:\\\\Program Files\\\\Matlab\\\\bin\\\\win64\"\r\n#define SFCN_FMI_MEXEXT                \"mexw64\"\r\n#define SFCN_FMI_NBR_MEX               0\r\n\r\nstatic const char* SFCN_FMI_MEX_NAMES[1] = { \"\" };\r\n\r\nextern void sfcn_fmi_mxGlobalTunable_(SimStruct* S, int_T create, int_T update);\r\nextern void* sfcn_fmi_allocateBusObject(int_T isInput, int_T portid, int_T width);\r\nextern void sfcn_fmi_registerMdlCallbacks_(SimStruct* S);\r\nextern void sfcn_fmi_registerRTModelCallbacks_(SimStruct*S);\r\nextern void sfcn_fmi_copyToSFcnParams_(SimStruct* S);\r\nextern void sfcn_fmi_mxGlobalTunable_(SimStruct* S, int_T create, int_T update);\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};