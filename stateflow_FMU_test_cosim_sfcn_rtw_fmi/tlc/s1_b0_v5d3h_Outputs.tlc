%implements s1_b0_v5d3h_Outputs "C"

%function Outputs(block, system) Output
%assign cfgTxt = ""
%openfile cfgTxt
%assign localVarDecl = ""
%openfile localVarDecl

B_stateflow_FMU_test_cosim_T *_rtB;
%closefile localVarDecl
%<SLibCG_TrackBlockIO(1)>\
_rtB = %<(SLibCG_SE(SLibGetBlockIOStructPtr()))>;
%<SLibCG_TrackEO(5)>\
%<SLibCG_TrackEO(4)>\
%<SLibCG_TrackEO(3)>\
%<SLibCG_TrackEO(2)>\
%<SLibCG_TrackEO(1)>\
%<SLibCG_TrackEO(0)>\
%<SLibCG_TrackEI(5)>\
%<SLibCG_TrackEI(4)>\
%<SLibCG_TrackEI(3)>\
%<SLibCG_TrackEI(2)>\
%<SLibCG_TrackEI(1)>\
%<SLibCG_TrackEI(0)>\
/* {S!d118}Chart: '<Root>/State Flow FMU Test' */
/* Gateway: State Flow FMU Test */
/* During: State Flow FMU Test */
if (%<(SLibCG_SE(SLibCG_DWV(0, 0, 1, 1, "", -1, "", 0)))> == 0U) {
    /* Entry: State Flow FMU Test */
%<SLibCG_SetDWV(0, 0, 1, 1, "", -1, "", 0, "1U")>\
    /* Entry Internal: State Flow FMU Test */
    /* Transition: '<S1>:2' */
%<SLibCG_SetDWV(1, 0, 1, 1, "", -1, "", 0, "stateflow_FMU_test_cos_IN_start")>\
    /* Entry 'start': '<S1>:1' */
    _rtB->startState = 1.0;
    _rtB->delayState = 1.0;
} else {
    switch (%<(SLibCG_DWV(1, 0, 1, 1, "", -1, "", 0))>) {
      case stateflow_FMU_test_cos_IN_delay:
        /* During 'delay': '<S1>:6' */
        if (*((const real_T **)ssGetInputPortSignalPtrs(S, 0))[0] == 0.0) {
            /* Transition: '<S1>:16' */
%<SLibCG_SetDWV(1, 0, 1, 1, "", -1, "", 0, "stateflow_FMU_test_cosi_IN_wait")>\
            /* Entry 'wait': '<S1>:5' */
            _rtB->waitState = 1.0;
        } else if (*((const real_T **)ssGetInputPortSignalPtrs(S, 3))[0] == 1.0) {
            /* Transition: '<S1>:18' */
%<SLibCG_SetDWV(1, 0, 1, 1, "", -1, "", 0, "stateflow_FMU_test_cos_IN_queue")>\
            /* Entry 'queue': '<S1>:7' */
        }
        break;
      case stateflow_FMU_test_cosim_IN_off:
        /* During 'off': '<S1>:4' */
        if ((*((const real_T **)ssGetInputPortSignalPtrs(S, 5))[0] == 0.0) && (*((const real_T **)ssGetInputPortSignalPtrs(S, 1))[0] == 0.0)) {
            /* Transition: '<S1>:12' */
%<SLibCG_SetDWV(1, 0, 1, 1, "", -1, "", 0, "stateflow_FMU_test_cos_IN_start")>\
            /* Entry 'start': '<S1>:1' */
            _rtB->startState = 1.0;
            _rtB->delayState = 1.0;
        } else if (*((const real_T **)ssGetInputPortSignalPtrs(S, 2))[0] == 1.0) {
            /* Transition: '<S1>:22' */
%<SLibCG_SetDWV(1, 0, 1, 1, "", -1, "", 0, "stateflow_FMU_test_cosim_IN_on")>\
            /* Entry 'on': '<S1>:3' */
            _rtB->onState = 1.0;
        }
        break;
      case stateflow_FMU_test_cosim_IN_on:
        /* During 'on': '<S1>:3' */
        if ((*((const real_T **)ssGetInputPortSignalPtrs(S, 4))[0] == 1.0) && (*((const real_T **)ssGetInputPortSignalPtrs(S, 2))[0] == 1.0)) {
            /* Transition: '<S1>:10' */
%<SLibCG_SetDWV(1, 0, 1, 1, "", -1, "", 0, "stateflow_FMU_test_cosi_IN_wait")>\
            /* Entry 'wait': '<S1>:5' */
            _rtB->waitState = 1.0;
        } else if (*((const real_T **)ssGetInputPortSignalPtrs(S, 1))[0] == 1.0) {
            /* Transition: '<S1>:21' */
%<SLibCG_SetDWV(1, 0, 1, 1, "", -1, "", 0, "stateflow_FMU_test_cosim_IN_off")>\
            /* Entry 'off': '<S1>:4' */
        } else {
            _rtB->onState = 1.0;
        }
        break;
      case stateflow_FMU_test_cos_IN_queue:
        /* During 'queue': '<S1>:7' */
        if (*((const real_T **)ssGetInputPortSignalPtrs(S, 3))[0] == 1.0) {
            /* Transition: '<S1>:19' */
%<SLibCG_SetDWV(1, 0, 1, 1, "", -1, "", 0, "stateflow_FMU_test_cos_IN_delay")>\
            /* Entry 'delay': '<S1>:6' */
        } else if (*((const real_T **)ssGetInputPortSignalPtrs(S, 1))[0] == 1.0) {
            /* Transition: '<S1>:23' */
%<SLibCG_SetDWV(1, 0, 1, 1, "", -1, "", 0, "stateflow_FMU_test_cosim_IN_off")>\
            /* Entry 'off': '<S1>:4' */
        }
        break;
      case stateflow_FMU_test_cos_IN_start:
        /* During 'start': '<S1>:1' */
        if ((*((const real_T **)ssGetInputPortSignalPtrs(S, 5))[0] == 1.0) && (*((const real_T **)ssGetInputPortSignalPtrs(S, 2))[0] == 1.0)) {
            /* Transition: '<S1>:8' */
%<SLibCG_SetDWV(1, 0, 1, 1, "", -1, "", 0, "stateflow_FMU_test_cosim_IN_on")>\
            /* Entry 'on': '<S1>:3' */
            _rtB->onState = 1.0;
        } else if ((*((const real_T **)ssGetInputPortSignalPtrs(S, 1))[0] == 1.0) && (*((const real_T **)ssGetInputPortSignalPtrs(S, 5))[0] == 0.0)) {
            /* Transition: '<S1>:17' */
%<SLibCG_SetDWV(1, 0, 1, 1, "", -1, "", 0, "stateflow_FMU_test_cosim_IN_off")>\
            /* Entry 'off': '<S1>:4' */
        } else {
            _rtB->startState = 1.0;
            _rtB->delayState = 1.0;
        }
        break;
      default:
        /* During 'wait': '<S1>:5' */
        if ((*((const real_T **)ssGetInputPortSignalPtrs(S, 4))[0] == 1.0) && (*((const real_T **)ssGetInputPortSignalPtrs(S, 2))[0] == 0.0)) {
            /* Transition: '<S1>:11' */
%<SLibCG_SetDWV(1, 0, 1, 1, "", -1, "", 0, "stateflow_FMU_test_cosim_IN_on")>\
            /* Entry 'on': '<S1>:3' */
            _rtB->onState = 1.0;
        } else if (*((const real_T **)ssGetInputPortSignalPtrs(S, 0))[0] == 1.0) {
            /* Transition: '<S1>:13' */
%<SLibCG_SetDWV(1, 0, 1, 1, "", -1, "", 0, "stateflow_FMU_test_cos_IN_delay")>\
            /* Entry 'delay': '<S1>:6' */
        } else {
            _rtB->waitState = 1.0;
        }
        break;
    }
}
/* {E!d118}End of Chart: '<Root>/State Flow FMU Test' */

/* {S!d120}Outport: '<Root>/waitState' */
((real_T *)ssGetOutputPortSignal(S, 0))[0] = _rtB->waitState;
/* {S!d122}Outport: '<Root>/onState' */
((real_T *)ssGetOutputPortSignal(S, 1))[0] = _rtB->onState;
/* {S!d124}Outport: '<Root>/offState' */
((real_T *)ssGetOutputPortSignal(S, 2))[0] = _rtB->offState;
/* {S!d126}Outport: '<Root>/delayState' */
((real_T *)ssGetOutputPortSignal(S, 3))[0] = _rtB->delayState;
/* {S!d128}Outport: '<Root>/queueState' */
((real_T *)ssGetOutputPortSignal(S, 4))[0] = _rtB->queueState;
/* {S!d130}Outport: '<Root>/startState' */
((real_T *)ssGetOutputPortSignal(S, 5))[0] = _rtB->startState;
%<SLibInsertSolverResetCode()>\
%closefile cfgTxt
%<cfgTxt>
%assign rtmArgSys = ::CompiledModel.System[::CompiledModel.System[::CompiledModel.RTWCGModules.RTWCGModule[0].CGSystemIdx].NonInlinedParentSystemIdx]
%if SysFcnArgNeeded("Output", rtmArgSys.Interface.RTMArgDef, rtmArgSys.CurrentTID, FcnSysModuleIsRateGrouping(rtmArgSys, "Output"))
%<SLibCG_AccessArg(0, 2, 0)>
%endif
%if SLibCG_ArgAccessed(0, 2, 0)
%<SLibAccessArg(rtmArgSys.Interface.RTMArgDef, "Output", rtmArgSys.CurrentTID, FcnSysModuleIsRateGrouping(rtmArgSys, "Output"))>
%endif
%if (IsModelReferenceBaseSys(rtmArgSys) && (IsModelRefScalableBuild() || GenerateClassInterface)) ||...
(GenerateClassInterface && SLibIsMultiInstanceServer(rtmArgSys))
%<SLibCG_UndoAccessArg(0, 2, 0)>
%endif
%<LibSetSystemField(system, "CachedOutputLocalVars", localVarDecl)>
%endfunction
%function OutputsFcnProtoType(block, system) Output
%assign fcnProtoType = ""
%openfile fcnProtoType
static void Outputs(\
%assign comma = ""
%<comma>%<::tSimStructType> *S\
%assign comma = ", "
%<SLibUpdateSymbolForFunction("Outputs", SLibGetFcnDefinitionRTMSymbolName(), TLC_FALSE)>\
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 2, fcnProtoType)>
%endfunction
